{"version":3,"sources":["../../src/defaultTheme.tsx","../../src/chief/utils/with-chief-on-plugIn.tsx","../../src/chief/utils/create-editor.tsx","../../src/chief/chief-context.tsx","../../src/chief/utils/saved-selection.tsx","../../src/chief/chief.tsx","../../src/utils.ts","../../src/override-theme.tsx","../../src/chief/hooks/use-chief.tsx","../../src/chief/handlers/handleRenderLeaf.tsx","../../src/chief/utils/matches-type.tsx","../../src/chief/handlers/handleRenderElement.tsx","../../src/chief/editor.tsx","../../src/chief/handlers/handleDecorate.tsx","../../src/chief/handlers/handleKeyDown.tsx","../../src/chief/handlers/handleKeyUp.tsx","../../src/chief/chief-presentation.tsx","../../src/chief/hooks/use-labels.tsx","../../src/chief/hooks/use-on-key-down.tsx","../../src/chief/hooks/use-plugin.tsx","../../src/chief/hooks/use-render-element.tsx","../../src/chief/hooks/use-render-leaf.tsx","../../src/placeholder-hint.tsx","../../src/leaf-renderer.tsx","../../src/ui/ui-wrap.tsx","../../src/ui/button-base.tsx","../../src/ui/styled-toolbar-btn.tsx","../../src/element-hover-tip.tsx","../../src/ToolbarBtn.tsx","../../src/mark-button.tsx","../../src/shortcut.ts","../../src/chief/controls/index.tsx","../../src/addons/italic/index.tsx","../../src/addons/underline/index.tsx","../../src/addons/strikethrough/index.tsx","../../src/addons/headings/Heading.tsx","../../src/addons/headings/index.tsx","../../src/addons/prevent-newline/index.tsx","../../src/addons/reset-to-paragraph/index.tsx","../../src/addons/labels/index.tsx","../../src/addons/paragraph/paragraph-element.tsx","../../src/addons/paragraph/index.tsx","../../src/addons/bold/index.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/FileUpload.tsx","../../node_modules/ts-is-present/lib/index.js","../../src/show.tsx","../../src/element-wrapper.tsx","../../src/Focused.ts","../../src/ToolsWrapper.tsx","../../src/StyledToolBox.tsx","../../src/ui/StyledFocusToolbar.tsx","../../src/ui/WithAttentionToolbar.tsx","../../src/InputWrapper.tsx","../../src/ui/button.tsx","../../src/ToolBtnPopup.tsx","../../src/addons/image/image-element.tsx","../../src/addons/image/index.tsx","../../src/addons/link/index.tsx","../../src/element-utils.ts","../../src/addons/lists/transforms.ts","../../src/element-renderer.tsx","../../src/chief/chief-state.ts","../../src/addons/lists/index.tsx","../../src/addons/lists/controls.tsx","../../src/addons/block-tab/index.tsx","../../src/addons/block-insert-tool/block-insert.tsx","../../src/chief/utils/use-highlight-selection.tsx","../../src/chief/hooks/use-decoration.tsx","../../src/addons/hovering-tool/hovering-tool.tsx","../../src/addons/text-color/index.tsx","Kitchensink.tsx","index.tsx"],"names":["defaultTheme","colors","primary","seconday","gray","100","200","300","400","500","600","700","800","900","originalEntries","createEditor","plugins","editor","useMemo","withReact","withHistory","createSlateEditor","prop","value","editorFn","plugin","Object","withChiefOnPlugIn","useChiefRenderCore","useState","renderLeafs","setRenderLeafs","renderElements","setRenderElements","injectRenderLeaf","it","removeRenderLeaf","toSlicer","injectRenderElement","removeRenderElement","ChiefContext","React","count","savedSelectionContext","useSaveSelection","context","useContext","Error","SavedSelectionProvider","props","useSlate","editorRef","useRef","savedSelection","setSaveSelection","saveSelection","useCallback","selection","sRef","Editor","setTimeout","ReactEditor","Transforms","useProvideContext","isChiefElement","element","Chief","children","onChange","readOnly","id","theme","_theme","merge","chiefValue","injectedPlugins","setInjectedPlugins","injectedLabels","setInjectedLabels","onKeyHandlers","setOnKeyHandlers","decorations","setDecorations","Boolean","setReadOnly","current","injectOnKeyHandler","a","b","removeOnKeyHandler","onKeyDownHandlers","injectPlugin","removePlugin","OnPlugins","labels","injectLabels","injectDecoration","removeDecoration","useProvideChiefContext","ErrorBoundary","useErrorBoundary","isNodeActive","at","match","n","useOnClickOutside","ref","handler","useEffect","listener","event","document","getNodeFromSelection","path","getAncestor","level","parent","node","e","OverrideTheme","name","useChief","ctx","handleRenderLeaf","copy","leaf","renderLeaf","matchesType","typeMatch","Array","handleRenderElement","renderElement","RichEditor","insertBlock","type","text","EditorThemeWrapper","styled","otherProps","decorate","ranges","result","handleDecorate","entry","keyDown","isHotkey","handleKeyDown","keyUp","SlateEditor","handleKeyUp","click","paste","clipboardData","onDOMBeforeInput","onKeyDown","onKeyUp","onClick","onPaste","useLabels","getLabel","label","useOnKeyDown","deps","chief","usePlugin","useRenderElement","ire","useRenderLeaf","irl","PlaceholderHint","leafType","rectType","elementProps","Leaf","attributes","uiStyle","css","UiWrap","ButtonBase","StyledToolbarBtn","ElementHoverTip","containerRef","overlayRef","setValue","handleMouseOver","handleMouseOut","useHover","triggerRef","isHovering","isOverlayHovering","over","setOver","handleMove","bounds","rect","x","y","window","useGlobalHover","isOverlayHoveringRef","isHoveringRef","show","setShow","delayed","tip","overlayProps","overlay","container","target","arrowProps","placement","style","contentEditable","position","width","StyledTooltipBody","Arrow","p","Tooltip","ToolbarBtn","onMouseDown","tooltip","useTheme","isActive","toggleFormat","format","isFormatted","isMark","Text","split","MarkBtn","shortcutText","shortcut","toKeyName","useIsControlEligable","opts","voids","ItalicControl","isText","key","defaultLabel","markType","_renderLeaf","Presenter","ItalicAddon","pattern","UnderlineControl","isEmpty","UnderlineAddon","StrikethroughControl","StrikethroughAddon","Heading","useEditor","isFocused","useFocused","isSelected","useSelected","placeholder","h1","h2","h3","h4","h5","h6","undefined","headingTypes","HeadingControl","heading","HeadingsAddon","_props","Range","Element","PreventNewlineAddon","ResetToParagraphAddon","deleteBackward","isParagraph","LabelsAddon","ParagraphElement","hoverHint","hint","ParagraphControl","ParagraphAddon","showHint","showPlaceholder","ParagraphPresenter","BoldAddon","action","BoldControl","Symbol","iterator","asyncIterator","HiddenFileInput","FileUpload","defineProperty","exports","t","Show","when","ElementWrapper","attentionChildren","isFocusedWithin","focus","setFocus","Path","inside","setInside","onMouseEnter","onMouseLeave","zIndex","ToolsWrapper","StyledToolBase","StyledToolBox","StyledFocusToolBtn","StyledFocusToolbar","WithAttentionToolbar","btns","renderElementProps","right","marginTop","marginRight","Input","InputWrapper","Button","ToolBtnPopup","toolWindow","modifiers","options","offset","ImageBlock","focused","selected","onOpenFileRequest","onRemoved","embedUrl","setEmbedUrl","isReplacing","setIsReplacing","handleSubmitEmbed","url","align","handleDelete","handleUpload","handleResize","height","h","toggleReplace","imageHandler","src","renderContent","renderToolBtn","tprops","display","justifyContent","onResize","w","resize","overflow","draggable","objectFit","alt","caption","onSubmit","disabled","isUrl","outline","StyledImageEmptyContainer","isImageElement","ImageControl","getAllImageNodes","mode","anchor","findNodes","images","ImageAddon","fileRef","isVoid","insertData","data","files","file","reader","image","insertImage","imageUrls","JSON","accept","imageRef","dataUrl","HistoryEditor","onUploadRequest","body","recover","then","onUploadedSuccess","error","multiple","LinkAddon","insertText","wrapLink","isInline","isLinkELement","href","LinkControl","isLinkActive","onClose","link","unwrapLink","isCollapsed","edge","LinkPopup","linkWrapperRef","linkNode","_linkNode","setUrl","handleInsertLink","insertLink","handleUnlink","padding","minWidth","flexDirection","autoFocus","rounded","toggleList","isElementActive","TYPE_LIST_ITEM","list","getState","point","isSelectionExpanded","isSelectionCollapsed","isElementEmpty","Node","elementType","TYPE_UNORDERED_LIST","TYPE_ORDERED_LIST","LIST_TYPES","Ul","Ol","Li","_renderElement","ListsAddon","normalizeNode","includes","ancestor","active","getActiveNode","listParent","index","otherList","destination","to","child","ListControl","BlockTabAddon","priority","BlockInsertBtn","BlockInsert","coords","setCoords","showMenu","setShowMenu","toolboxRef","hoveredNode","setNode","rootNode","firstDOMPoint","err","useHoveredNode","handleBlockInsert","top","left","useHighlightSelection","decoration","useDecoration","decorator","highlightSelection","hoverToolContext","HoverTools","isEditorFocused","currentNode","isReadOnly","backgroundColor","enabled","setEnabled","onChangeEnabled","HoveringTool","deltaOffset","setDeltaOffset","deltaoffset","toolRef","getBoundingClientRect","bottom","_v","_setV","domNode","console","domSelection","domRange","referenceElement","TextColorAddon","color","TextColorControl","ColorSelector","wrapperRef","handleChangeTextColor","margin","cursor","i","Icon","size","editorLabels","ColumnsAddon","nodes","preventDefault","flex","border","Children","map","ContentStyle","div","App","lorem","log","stringify","overrides","marginLeft","mdiFormatParagraph","mdiFormatHeader1","mdiFormatHeader2","mdiFormatHeader3","mdiFormatHeader4","mdiFormatHeader5","mdiFormatHeader6","mdiFormatListNumbered","mdiFormatListBulleted","mdiImage","mdiFormatBold","mdiFormatItalic","mdiFormatStrikethrough","mdiFormatUnderline","mdiLink","mdiFormatColorText","spellCheck","minHeight","ReactDOM","render","Kitchensink","getElementById"],"mappings":"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","file":"static/js/main.51903087.chunk.js","sourcesContent":["import { ChiefEditorTheme } from \"./chief-editor-theme\";\n\nexport const defaultTheme: ChiefEditorTheme = {\n  colors: {\n    primary: \"#4299E1\",\n    seconday: \"#38B2AC\",\n    gray: {\n      100: \"#F7FAFC\",\n      200: \"#EDF2F7\",\n      300: \"#E2E8F0\",\n      400: \"#CBD5E0\",\n      500: \"#A0AEC0\",\n      600: \"#718096\",\n      700: \"#4A5568\",\n      800: \"#2D3748\",\n      900: \"#1A202C\"\n    }\n  }\n};\n","import { ReactEditor } from \"slate-react\";\nimport { OnPlugin } from \"../../addon\";\n\n// Use this to save the originals of the editor functions\nlet originalEntries = {};\n/**\n * Allows for dynamically hook in and out of plugins.\n * Only overriding functions of the Editor is supported.\n * @param editor\n * @param plugins\n */\nexport function withChiefOnPlugIn(editor: ReactEditor, plugins: OnPlugin[]) {\n  // We basically take control over each function in the editor and route them\n  // to the appropriate addon that has requested overriding it.\n  // This allows for us to use hooks that can mount and unmount.\n  for (const [prop, value] of Object.entries(editor)) {\n    if (typeof value === \"function\") {\n      if (!(prop in originalEntries)) {\n        originalEntries[prop] = value;\n      }\n      editor[prop] = (...args: any[]) => {\n        let editorFn = originalEntries[prop];\n        for (const plugin of plugins) {\n          if (plugin && prop in plugin) {\n            editorFn = plugin && plugin[prop](editorFn, editor);\n          }\n        }\n        return editorFn(...args);\n      };\n    }\n  }\n\n  return editor;\n}\n","import { useMemo } from \"react\";\nimport { ReactEditor, withReact } from \"slate-react\";\nimport { createEditor as createSlateEditor } from \"slate\";\nimport { withHistory } from \"slate-history\";\nimport { OnPlugin } from \"../../addon\";\nimport { withChiefOnPlugIn } from \"./with-chief-on-plugIn\";\n\nexport const createEditor = (plugins: OnPlugin[]): ReactEditor => {\n  const editor = useMemo(() => withReact(withHistory(createSlateEditor())), []);\n  return useMemo(() => withChiefOnPlugIn(editor, plugins), [plugins]);\n};\n","import React, { useState, useRef } from \"react\";\nimport { ReactEditor, Editable } from \"slate-react\";\nimport { OnPlugin } from \"../addon\";\nimport { KeyHandler } from \"./key-handler\";\nimport { createEditor } from \"./utils/create-editor\";\nimport {\n  InjectedRenderLeaf,\n  InjectedRenderElement,\n  InjectedLabels,\n  InjectedDecorator\n} from \"./chief\";\ninterface ChiefRenderCore {\n  injectRenderLeaf: (irl: InjectedRenderLeaf) => void;\n  removeRenderLeaf: (irl: InjectedRenderLeaf) => void;\n  renderLeafs: Array<InjectedRenderLeaf>;\n  injectRenderElement: (irl: InjectedRenderElement<any>) => void;\n  removeRenderElement: (irl: InjectedRenderElement<any>) => void;\n  renderElements: InjectedRenderElement[];\n}\n\nexport function useChiefRenderCore() {\n  const [renderLeafs, setRenderLeafs] = useState<InjectedRenderLeaf[]>([]);\n  const [renderElements, setRenderElements] = useState<InjectedRenderElement[]>(\n    []\n  );\n  function injectRenderLeaf(irl: InjectedRenderLeaf) {\n    setRenderLeafs(it => [...it, irl]);\n  }\n\n  function removeRenderLeaf(irl: InjectedRenderLeaf) {\n    setRenderLeafs(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(toSlicer.indexOf(irl), 1);\n      return toSlicer;\n    });\n  }\n\n  function injectRenderElement(ire: InjectedRenderElement) {\n    setRenderElements(it => [...it, ire]);\n  }\n\n  function removeRenderElement(ire: InjectedRenderElement) {\n    setRenderElements(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(it.indexOf(ire), 1);\n      return toSlicer;\n    });\n  }\n\n  return {\n    renderLeafs,\n    injectRenderLeaf,\n    removeRenderLeaf,\n    renderElements,\n    injectRenderElement,\n    removeRenderElement\n  };\n}\n\nexport interface ChiefContextValue extends ChiefRenderCore {\n  editor: ReactEditor;\n  readOnly: boolean;\n  setReadOnly: (readOnly: boolean) => void;\n  id: string;\n  injectOnKeyHandler: (keyHandler: KeyHandler) => void;\n  removeOnKeyHandler: (keyHandler: KeyHandler) => void;\n  onKeyDownHandlers: KeyHandler[];\n  injectPlugin: (plugin: OnPlugin) => void;\n  removePlugin: (plugin: OnPlugin) => void;\n  OnPlugins: OnPlugin[];\n  labels: InjectedLabels;\n  injectLabels: (labels: InjectedLabels) => void;\n  decorations: InjectedDecorator[];\n  injectDecoration: (decoration: InjectedDecorator) => void;\n  removeDecoration: (decoration: InjectedDecorator) => void;\n}\nexport const ChiefContext = React.createContext<ChiefContextValue | null>(null);\nlet count = 1;\nexport function useProvideChiefContext(props: {\n  readOnly?: boolean;\n  id?: string;\n}) {\n  const [injectedPlugins, setInjectedPlugins] = useState<OnPlugin[]>([]);\n  const [injectedLabels, setInjectedLabels] = useState<InjectedLabels>({});\n  const [onKeyHandlers, setOnKeyHandlers] = useState<KeyHandler[]>([]);\n  const [decorations, setDecorations] = useState<InjectedDecorator[]>([]);\n  const editor = createEditor(injectedPlugins);\n  const [readOnly, setReadOnly] = useState(Boolean(props.readOnly));\n  const { current: id } = useRef(props.id || `chiefeditor${count++}`);\n\n  function injectPlugin(plugin: OnPlugin) {\n    setInjectedPlugins(plugins => [...plugins, plugin]);\n  }\n\n  function removePlugin(plugin: OnPlugin) {\n    setInjectedPlugins(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(toSlicer.indexOf(plugin), 1);\n      return toSlicer;\n    });\n  }\n\n  function injectOnKeyHandler(keyHandler: KeyHandler) {\n    setOnKeyHandlers(it =>\n      [...it, keyHandler].sort((a, b) =>\n        a.priority === b.priority ? 0 : a.priority === \"low\" ? 1 : -1\n      )\n    );\n  }\n\n  function removeOnKeyHandler(keyHandler: KeyHandler) {\n    setOnKeyHandlers(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(it.indexOf(keyHandler), 1);\n      return toSlicer;\n    });\n  }\n\n  function injectDecoration(decorator: InjectedDecorator) {\n    setDecorations(it =>\n      [...it, decorator].sort((a, b) =>\n        a.priority === b.priority ? 0 : a.priority === \"low\" ? 1 : -1\n      )\n    );\n  }\n\n  function removeDecoration(decorator: InjectedDecorator) {\n    setDecorations(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(it.indexOf(decorator), 1);\n      return toSlicer;\n    });\n  }\n\n  function injectLabels(labels: InjectedLabels) {\n    setInjectedLabels(it => ({ ...it, ...labels }));\n  }\n\n  const value: ChiefContextValue = {\n    ...useChiefRenderCore(),\n    editor,\n    readOnly,\n    setReadOnly,\n    id,\n    injectOnKeyHandler,\n    removeOnKeyHandler,\n    onKeyDownHandlers: onKeyHandlers,\n    injectPlugin,\n    removePlugin,\n    OnPlugins: injectedPlugins,\n    labels: injectedLabels,\n    injectLabels,\n    decorations,\n    injectDecoration,\n    removeDecoration\n  };\n\n  return value;\n}\n","import React, {\n  ReactNode,\n  useCallback,\n  useContext,\n  useRef,\n  useState\n} from \"react\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { Editor, Range, Transforms, RangeRef } from \"slate\";\n\ntype Context = ReturnType<typeof useProvideContext>;\n\nconst savedSelectionContext = React.createContext<Context | undefined>(\n  undefined\n);\n\nexport function useSaveSelection() {\n  const context = useContext(savedSelectionContext);\n  if (!context) {\n    throw new Error(\"No SavedSelectionProvider.\");\n  }\n  return context;\n}\n\nexport function SavedSelectionProvider(props: { children: ReactNode }) {\n  const value = useProvideContext();\n  return (\n    <savedSelectionContext.Provider value={value}>\n      {props.children}\n    </savedSelectionContext.Provider>\n  );\n}\n\nfunction useProvideContext() {\n  const editor = useSlate();\n  const editorRef = useRef(editor);\n  editorRef.current = editor;\n\n  const [savedSelection, setSaveSelection] = useState<RangeRef | null>(null);\n  const saveSelection = useCallback((selection: Range | null) => {\n    if (selection !== null) {\n      const sRef = Editor.rangeRef(editor, selection);\n      setSaveSelection(sRef);\n      return () => {\n        if (sRef.current) {\n          setTimeout(() => {\n            ReactEditor.focus(editorRef.current);\n            Transforms.select(editorRef.current, sRef.current!);\n            setSaveSelection(null);\n            sRef.unref();\n          }, 0);\n        }\n      };\n    }\n    return () => null;\n  }, []);\n  return { saveSelection, savedSelection };\n}\n","import React, { useEffect } from \"react\";\nimport {\n  RenderLeafProps,\n  ReactEditor,\n  RenderElementProps,\n  Slate\n} from \"slate-react\";\nimport { Node, Element, NodeEntry, Range } from \"slate\";\nimport merge from \"lodash/merge\";\nimport { ChiefEditorTheme } from \"../chief-editor-theme\";\nimport { ThemeProvider } from \"styled-components\";\nimport { defaultTheme } from \"../defaultTheme\";\nimport { useProvideChiefContext, ChiefContext } from \"./chief-context\";\nimport { useErrorBoundary } from \"use-error-boundary\";\nimport { SavedSelectionProvider } from \"./utils/saved-selection\";\n\nexport function isChiefElement(element: unknown): element is ChiefElement {\n  return (element as ChiefElement).type !== undefined;\n}\n\nexport type ChiefElement = Element & {\n  type: string;\n};\n\nexport type ChiefRenderElementProps<\n  T extends ChiefElement = ChiefElement\n> = RenderElementProps & {\n  element: T;\n};\n\nexport type ElementTypeMatch = RegExp | string | readonly string[];\n\nexport type InjectedRenderLeaf = {\n  renderLeaf: (\n    props: RenderLeafProps,\n    editor?: ReactEditor\n  ) => JSX.Element | undefined;\n};\n\nexport type InjectedRenderElement<T extends ChiefElement = ChiefElement> = {\n  typeMatch?: ElementTypeMatch;\n  Component?: React.FunctionComponent<ChiefRenderElementProps>;\n  renderElement?:\n    | JSX.Element\n    | ((\n        props: ChiefRenderElementProps<T>,\n        editor?: ReactEditor\n      ) => JSX.Element | undefined);\n};\n\nexport type InjectedLabels = { [key: string]: string | undefined };\nexport type Label = { key: string; defaultLabel: string };\n\nexport type InjectedDecorator = {\n  decorator: (\n    entry: NodeEntry<Node>,\n    editor: ReactEditor\n  ) => Range[] | undefined;\n  priority?: \"high\" | \"low\";\n};\n\nexport const Chief = React.memo(function(props: {\n  value: Node[];\n  onChange: (value: Node[]) => void;\n  children: React.ReactNode;\n  readOnly?: boolean;\n  id?: string;\n  theme?: ChiefEditorTheme & { [key: string]: any };\n}) {\n  const { children, onChange, value, readOnly, id, theme } = props;\n  const _theme = merge({}, defaultTheme, theme);\n  const chiefValue = useProvideChiefContext({ readOnly, id });\n  const { ErrorBoundary, didCatch, error } = useErrorBoundary();\n  return (\n    <ErrorBoundary>\n      <Slate editor={chiefValue.editor} value={value} onChange={onChange}>\n        <ChiefContext.Provider value={chiefValue}>\n          <SavedSelectionProvider>\n            <ThemeProvider theme={_theme}>\n              <React.Fragment>{children}</React.Fragment>\n            </ThemeProvider>\n          </SavedSelectionProvider>\n        </ChiefContext.Provider>\n      </Slate>\n    </ErrorBoundary>\n  );\n});\n","import { useEffect, useCallback, useState, useRef } from \"react\";\nimport { Editor, Point, Node, Transforms, Location } from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nimport { Range } from \"slate\";\n\nexport const isInside = (rect: ClientRect, x: number, y: number) => {\n  return (\n    x >= rect.left &&\n    x <= rect.left + rect.width &&\n    y >= rect.top &&\n    y <= rect.top + rect.height\n  );\n};\n\nexport const useGlobalHover = (element: HTMLElement | null) => {\n  const [over, setOver] = useState(false);\n\n  const handleMove = useCallback(\n    (event: MouseEvent) => {\n      if (element) {\n        const bounds = element.getBoundingClientRect();\n        setOver(isInside(bounds, event.clientX, event.clientY));\n      }\n    },\n    [element]\n  );\n\n  useEffect(() => {\n    window.addEventListener(\"mousemove\", handleMove);\n    return () => {\n      window.removeEventListener(\"mousemove\", handleMove);\n    };\n  }, [element]);\n  return over;\n};\n\nexport function useHover<T extends HTMLElement>(): [\n  React.RefObject<T>,\n  boolean\n] {\n  const [value, setValue] = useState(false);\n\n  const ref = useRef<T>(null);\n\n  const handleMouseOver = () => setValue(true);\n  const handleMouseOut = () => setValue(false);\n\n  useEffect(\n    () => {\n      const node = ref.current;\n      if (node) {\n        node.addEventListener(\"mouseover\", handleMouseOver);\n        node.addEventListener(\"mouseout\", handleMouseOut);\n\n        return () => {\n          node.removeEventListener(\"mouseover\", handleMouseOver);\n          node.removeEventListener(\"mouseout\", handleMouseOut);\n        };\n      }\n      return undefined;\n    },\n    [ref.current] // Recall only if ref changes\n  );\n\n  return [ref, value];\n}\n\nexport const getActiveNode = (editor: ReactEditor) => {\n  if (editor.selection) {\n    const [, path] = Editor.node(editor, editor.selection);\n    if (path.length) {\n      const [parent] = Editor.parent(editor, path);\n      return parent;\n    }\n  }\n  return null;\n};\n\nexport const getActiveNodeType = (editor: ReactEditor) => {\n  const block = getActiveNode(editor);\n  return block ? block.type : null;\n};\n\nexport const clone = (value: any) => {\n  return JSON.parse(JSON.stringify(value));\n};\n\ninterface State {\n  node: Node | null;\n  point: Point | null;\n  selection: Range | null;\n}\n\nexport const useLastFocused = (editor: ReactEditor) => {\n  const [state, setState] = useState<State>({\n    node: null,\n    point: null,\n    selection: null\n  });\n  const { selection } = editor;\n  const current = getActiveNodeType(editor);\n\n  useEffect(() => {\n    if (!ReactEditor.isFocused(editor)) {\n      return;\n    }\n    if (!selection) {\n      return;\n    }\n    if (current) {\n      const point = selection.focus;\n      const [node] = Editor.parent(editor, point);\n      if (Node.isNode(node)) {\n        setState({ node, point, selection: clone(selection) });\n      }\n    }\n  }, [current, selection]);\n\n  return state;\n};\n\nexport const isBlockEmpty = (editor: Editor, location?: Location) => {\n  let selection: Location | null = editor.selection;\n  if (location) {\n    selection = location;\n  }\n  if (selection) {\n    const [node] = Editor.node(editor, selection);\n    return Node.string(node).length === 0;\n  }\n\n  return false;\n};\n\nexport const toggleBlock = (editor: Editor, type: string) => {\n  const isActive = isNodeActive(editor, type);\n\n  Transforms.setNodes(editor, {\n    type: isActive ? \"paragraph\" : type\n  });\n};\n\nexport const isNodeActive = (editor: Editor, type: string) => {\n  const { selection } = editor;\n  if (!selection) {\n    return false;\n  }\n  const [match] = Editor.nodes(editor, {\n    at: selection,\n    match: n => n.type === type\n  });\n  return !!match;\n};\n\nexport function useOnClickOutside(\n  ref: React.MutableRefObject<any>,\n  handler: (event: MouseEvent | TouchEvent) => void\n) {\n  useEffect(\n    () => {\n      const listener = (event: MouseEvent | TouchEvent) => {\n        // Do nothing if clicking ref's element or descendent elements\n        if (!ref.current || ref.current.contains(event.target)) {\n          return;\n        }\n\n        handler(event);\n      };\n\n      document.addEventListener(\"mousedown\", listener);\n      document.addEventListener(\"touchstart\", listener);\n\n      return () => {\n        document.removeEventListener(\"mousedown\", listener);\n        document.removeEventListener(\"touchstart\", listener);\n      };\n    },\n    // Add ref and handler to effect dependencies\n    // It's worth noting that because passed in handler is a new ...\n    // ... function on every render that will cause this effect ...\n    // ... callback/cleanup to run every render. It's not a big deal ...\n    // ... but to optimize you can wrap handler in useCallback before ...\n    // ... passing it into this hook.\n    [ref, handler]\n  );\n}\n\nexport function getNodeFromSelection(editor: Editor, selection: Range | null) {\n  if (selection) {\n    const [, path] = Editor.node(editor, selection);\n    if (path.length) {\n      const [parent] = Editor.parent(editor, path);\n      return parent;\n    }\n  }\n  return null;\n}\n\nexport const findNodes = (editor: Editor, match: (node: Node) => boolean) => {\n  return Editor.nodes(editor, {\n    mode: \"all\",\n    at: {\n      anchor: Editor.start(editor, []),\n      focus: Editor.end(editor, [])\n    },\n    match\n  });\n};\n\nexport const getAncestor = (editor: ReactEditor, node: Node, level = 1) => {\n  let parent: Node | null = null;\n  let count = 0;\n  while (node && count !== level) {\n    count++;\n    try {\n      const path = ReactEditor.findPath(editor, node);\n      if (path.length === 0) {\n        return null;\n      }\n      parent = Editor.parent(editor, path)[0];\n      if (parent === editor) {\n        return null;\n      }\n      node = parent;\n    } catch (e) {}\n  }\n  return parent;\n};\n","import { css } from \"styled-components\";\nexport function OverrideTheme(\n  name: string,\n  props: {\n    theme: {\n      overrides?: {\n        [key: string]: ReturnType<typeof css>;\n      };\n    };\n  }\n) {\n  if (props.theme.overrides && props.theme.overrides[name]) {\n    return props.theme.overrides[name];\n  }\n  return undefined;\n}\n","import { useContext } from \"react\";\nimport { ChiefContext } from \"../chief-context\";\n\nexport function useChief() {\n  const ctx = useContext(ChiefContext);\n  if (!ctx) {\n    throw new Error(\n      'Chief context not found. Wrap your <Chief.Editor/> in a <Chief/> before using \"useChief()\"'\n    );\n  }\n  return ctx;\n}\n","import React from \"react\";\nimport { ReactEditor, RenderLeafProps } from \"slate-react\";\nimport { InjectedRenderLeaf } from \"../chief\";\nexport function handleRenderLeaf(\n  props: RenderLeafProps,\n  renderLeafs: InjectedRenderLeaf[],\n  editor?: ReactEditor\n) {\n  let copy = { ...props };\n  for (const renderLeaf of renderLeafs) {\n    const leaf = renderLeaf.renderLeaf(copy, editor);\n    if (leaf) {\n      copy = { ...copy, children: leaf };\n    }\n  }\n  return <span {...copy.attributes}>{copy.children}</span>;\n}\n","import { ElementTypeMatch, ChiefElement } from \"../chief\";\n\nexport function matchesType(\n  element: ChiefElement,\n  typeMatch?: ElementTypeMatch\n): element is ChiefElement {\n  return (\n    (Array.isArray(typeMatch) && typeMatch.includes(element.type)) ||\n    (typeof typeMatch === \"string\" && typeMatch === element.type) ||\n    Boolean(typeMatch instanceof RegExp && element.type.match(typeMatch))\n  );\n}\n","import React from \"react\";\nimport { ReactEditor } from \"slate-react\";\nimport { InjectedRenderElement, ChiefRenderElementProps } from \"../chief\";\nimport { matchesType } from \"../utils/matches-type\";\n\nexport function handleRenderElement(\n  props: ChiefRenderElementProps,\n  renderElements: InjectedRenderElement[],\n  editor?: ReactEditor\n) {\n  let element: JSX.Element | undefined;\n  for (let renderElement of renderElements) {\n    if (\n      renderElement.typeMatch === undefined ||\n      matchesType(props.element, renderElement.typeMatch)\n    ) {\n      if (renderElement.Component) {\n        element = <renderElement.Component {...props} />;\n      } else if (renderElement.renderElement) {\n        element =\n          typeof renderElement.renderElement === \"function\"\n            ? renderElement.renderElement(props, editor)\n            : React.cloneElement(renderElement.renderElement, props) || element;\n      }\n    }\n  }\n\n  return (element = element || <React.Fragment>{null}</React.Fragment>);\n}\n","import React, { useCallback } from \"react\";\nimport merge from \"lodash/merge\";\nimport orderBy from \"lodash/orderBy\";\nimport { Editor as SlateEditor, NodeEntry, Transforms } from \"slate\";\nimport {\n  Editable,\n  ReactEditor,\n  RenderElementProps,\n  RenderLeafProps\n} from \"slate-react\";\nimport styled from \"styled-components\";\nimport { isNodeActive } from \"../utils\";\nimport { OverrideTheme } from \"../override-theme\";\nimport { ChiefRenderElementProps } from \"./chief\";\nimport { useChief } from \"./hooks/use-chief\";\nimport { handleDecorate } from \"./handlers/handleDecorate\";\nimport { handleClick } from \"./handlers/handleClick\";\nimport { handleKeyUp } from \"./handlers/handleKeyUp\";\nimport { handleKeyDown } from \"./handlers/handleKeyDown\";\nimport { handleRenderLeaf } from \"./handlers/handleRenderLeaf\";\nimport { handleRenderElement } from \"./handlers/handleRenderElement\";\n\nexport const RichEditor = {\n  ...ReactEditor,\n  insertBlock(editor: SlateEditor, blockType: string) {\n    if (!isNodeActive(editor, blockType)) {\n      Transforms.setNodes(editor, {\n        type: blockType,\n        children: [{ text: \"\" }]\n      });\n    } else {\n      Transforms.insertNodes(editor, {\n        type: blockType,\n        children: [{ text: \"\" }]\n      });\n    }\n  }\n};\n\nconst EditorThemeWrapper = styled.div`\n  ${props => OverrideTheme(\"Editor\", props)}\n`;\n\nexport const Editor = React.memo(\n  (\n    props: {\n      children?: React.ReactNode;\n    } & React.ComponentProps<typeof Editable>\n  ) => {\n    const {\n      editor,\n      readOnly,\n      id,\n      renderLeafs,\n      renderElements,\n      onKeyDownHandlers,\n      decorations\n    } = useChief();\n    const { children, ...otherProps } = props;\n\n    const renderElement = useCallback(\n      (props: RenderElementProps) => {\n        return handleRenderElement(\n          props as ChiefRenderElementProps,\n          renderElements,\n          editor\n        );\n      },\n      [renderElements]\n    );\n\n    const renderLeaf = useCallback(\n      (props: RenderLeafProps) => {\n        return handleRenderLeaf(props, renderLeafs, editor);\n      },\n      [renderLeafs]\n    );\n\n    const decorate = useCallback(\n      (entry: NodeEntry) => handleDecorate(entry, editor, decorations),\n      [decorations]\n    );\n\n    const keyDown = useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        return handleKeyDown(event, editor, onKeyDownHandlers);\n      },\n      [onKeyDownHandlers]\n    );\n\n    // TODO\n    const keyUp = useCallback((event: React.KeyboardEvent<HTMLDivElement>) => {\n      handleKeyUp(event, editor);\n    }, []);\n    //TODO\n    const click = useCallback(\n      (event: React.MouseEvent<HTMLElement>) => handleClick(event, editor, []),\n      []\n    );\n\n    const paste = useCallback((event: React.ClipboardEvent<HTMLDivElement>) => {\n      const clipboardData = event.clipboardData;\n      const pastedData = clipboardData.getData(\"Text\");\n      if (!pastedData) {\n        return;\n      }\n      // editor.insertText(pastedData);\n    }, []);\n\n    // TODO\n    const onDOMBeforeInput = useCallback(e => {}, []);\n\n    return (\n      <React.Fragment>\n        <EditorThemeWrapper>\n          {children}\n          <Editable\n            onDOMBeforeInput={onDOMBeforeInput}\n            renderLeaf={renderLeaf}\n            renderElement={renderElement}\n            decorate={decorate}\n            onKeyDown={keyDown}\n            onKeyUp={keyUp}\n            onClick={click}\n            onPaste={paste}\n            readOnly={readOnly}\n            id={`${id}`}\n            {...otherProps}\n          />\n        </EditorThemeWrapper>\n      </React.Fragment>\n    );\n  }\n);\n","import { NodeEntry, Range } from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nimport { InjectedDecorator } from \"../chief\";\n// TODO\nexport const handleDecorate = (\n  entry: NodeEntry,\n  editor: ReactEditor,\n  decorators: InjectedDecorator[]\n) => {\n  let ranges: Range[] = [];\n  for (let decorate of decorators) {\n    const result = decorate.decorator(entry, editor);\n    if (result) {\n      return (ranges = ranges.concat(result));\n    }\n  }\n  return ranges;\n};\n","import React from \"react\";\nimport { ReactEditor } from \"slate-react\";\nimport { KeyHandler } from \"../key-handler\";\nimport isHotkey from \"is-hotkey\";\nexport const handleKeyDown = (\n  event: React.KeyboardEvent<HTMLDivElement>,\n  editor: ReactEditor,\n  onKeyHandlers: KeyHandler[]\n) => {\n  for (let handler of onKeyHandlers) {\n    if (handler.pattern) {\n      if (\n        isHotkey(handler.pattern, event.nativeEvent) &&\n        handler.handler(event.nativeEvent, editor)\n      ) {\n        return;\n      }\n    } else if (handler.pattern === null) {\n      if (handler.handler(event.nativeEvent, editor)) {\n        return;\n      }\n    }\n  }\n};\n","import React from \"react\";\nimport {\n  Editor as SlateEditor,\n  Location\n} from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nexport const handleKeyUp = (\n  event: React.KeyboardEvent<HTMLDivElement>,\n  editor: ReactEditor\n) => {\n  const { selection } = editor;\n  if (!selection) {\n    return;\n  }\n  const [, path] = SlateEditor.node(editor, selection as Location);\n  if (!path.length) {\n    return;\n  }\n  const [parent] = SlateEditor.parent(editor, path);\n  if (parent) {\n    // TODO: implement some kind of trigger\n    // for (let addon of addons) {\n    //   if (addon.triggers) {\n    //     for (let trigger of plugin.triggers) {\n    //       const matches = findMatches(trigger.pattern, trigger.range, editor);\n    //       if (matches.length) {\n    //         plugin.onTrigger && plugin.onTrigger(editor, matches, trigger);\n    //         return;\n    //       }\n    //     }\n    //   }\n    // }\n  }\n};\n","import React, { ReactNode, useCallback, useEffect } from \"react\";\nimport { RenderLeafProps } from \"slate-react\";\nimport { Node } from \"slate\";\nimport { handleRenderElement } from \"./handlers/handleRenderElement\";\nimport {\n  ChiefRenderElementProps,\n  InjectedRenderLeaf,\n  InjectedRenderElement,\n  ChiefElement\n} from \"./chief\";\nimport { handleRenderLeaf } from \"./handlers/handleRenderLeaf\";\nimport { useChiefRenderCore } from \"./chief-context\";\n\nexport type iPresenter<T extends ChiefElement = any> = {\n  element?: InjectedRenderElement<T>;\n  leaf?: InjectedRenderLeaf;\n};\n\ntype PresenterElementProps = Omit<ChiefRenderElementProps, \"attributes\">;\ntype PresenterLeafProps = Omit<RenderLeafProps, \"attributes\">;\ntype PresenterElement = PresenterElementProps[\"element\"];\n\ninterface SlatePresentationContextValue {\n  renderElement: (props: PresenterElementProps) => ReactNode;\n  renderLeaf: (props: PresenterLeafProps) => ReactNode;\n}\n\nconst SlatePresentationContext = React.createContext<SlatePresentationContextValue | null>(\n  null\n);\n\nfunction useSlatePresentation() {\n  const ctx = React.useContext(SlatePresentationContext);\n  if (!ctx) {\n    throw new Error(\"No SlatePresentationContext\");\n  }\n  return ctx;\n}\n\nfunction isElement(value: any) {\n  return value instanceof Object && Array.isArray(value.children);\n}\n\nfunction Element(props: { element: PresenterElement }) {\n  const { renderElement } = useSlatePresentation();\n  const { element } = props;\n  return (\n    <React.Fragment>\n      {renderElement({\n        children: <Children children={element.children} />,\n        element\n      })}\n    </React.Fragment>\n  );\n}\n\nfunction Leaf({ leaf = { text: \"\" } }: any) {\n  const { renderLeaf } = useSlatePresentation();\n\n  return (\n    <React.Fragment>\n      {renderLeaf({\n        children: <span>{leaf.text}</span>,\n        leaf,\n        text: leaf.text\n      })}\n    </React.Fragment>\n  );\n}\n\nfunction Children(props: { children: Node[] }) {\n  const { children } = props;\n  return (\n    <React.Fragment>\n      {children.map((child: any, i: number) => {\n        if (isElement(child)) {\n          return <Element key={i} element={child} />;\n        } else {\n          return <Leaf key={i} leaf={child} />;\n        }\n      })}\n    </React.Fragment>\n  );\n}\n\nexport function ChiefPresentation({\n  value = [],\n  presenters = [],\n  overrideRenderElement,\n  overrideRenderLeaf\n}: {\n  value: Node[];\n  presenters: iPresenter[];\n  overrideRenderElement?: (\n    props: PresenterElementProps\n  ) => JSX.Element | undefined;\n  overrideRenderLeaf?: (props: PresenterLeafProps) => JSX.Element | undefined;\n}) {\n  const {\n    renderLeafs,\n    renderElements,\n    injectRenderElement,\n    injectRenderLeaf\n  } = useChiefRenderCore();\n\n  useEffect(() => {\n    for (const presenter of presenters) {\n      if (presenter.element) {\n        injectRenderElement(presenter.element);\n      }\n      if (presenter.leaf) {\n        injectRenderLeaf(presenter.leaf);\n      }\n    }\n  }, []);\n\n  return (\n    <SlatePresentationContext.Provider\n      value={{\n        renderElement: useCallback(\n          (props: PresenterElementProps) => {\n            const overridedElement =\n              overrideRenderElement && overrideRenderElement(props);\n            if (overridedElement) {\n              return overridedElement;\n            }\n            return handleRenderElement(props as any, renderElements);\n          },\n          [renderElements]\n        ),\n        renderLeaf: useCallback(\n          (props: PresenterLeafProps) => {\n            const overridedLeaf =\n              overrideRenderLeaf && overrideRenderLeaf(props);\n            if (overridedLeaf) {\n              return overridedLeaf;\n            }\n            return handleRenderLeaf(props as any, renderLeafs);\n          },\n          [renderLeafs]\n        )\n      }}\n    >\n      <Children children={value} />\n    </SlatePresentationContext.Provider>\n  );\n}\n","import { useEffect, useCallback } from \"react\";\nimport { InjectedLabels, Label } from \"../chief\";\nimport { useChief } from \"./use-chief\";\n\nexport function useLabels(labels?: InjectedLabels) {\n  const { labels: injectedLabels, injectLabels } = useChief();\n  const getLabel = useCallback(\n    (label: Label) => {\n      if (typeof injectedLabels[label.key] === \"string\") {\n        return injectedLabels[label.key];\n      }\n      return label.defaultLabel;\n    },\n    [injectedLabels]\n  );\n\n  useEffect(() => {\n    if (labels) {\n      injectLabels(labels);\n    }\n  }, []);\n\n  return [getLabel, injectLabels] as const;\n}\n","import { useEffect } from \"react\";\nimport { useChief } from \"./use-chief\";\nimport { KeyHandler } from \"../key-handler\";\n/**\n * Respond to onKeyDown events in the editor.\n * If you want to receive all onKeyDown events, you can leave out the pattern.\n * For responding to certain key down combos, you can specify a key pattern, eg. \"mod+b\".\n * @param handler Function to call when a key or combo is pressed\n * @param overrides\n * @param deps\n */\n\nexport function useOnKeyDown(handler: KeyHandler, deps: any[] = []) {\n  const chief = useChief();\n  useEffect(() => {\n    if (handler.pattern !== null) {\n      chief.injectOnKeyHandler(handler);\n    }\n    return () => chief.removeOnKeyHandler(handler);\n  }, deps);\n}\n","import { useEffect } from \"react\";\nimport { OnPlugin } from \"../../addon\";\nimport { useChief } from \"./use-chief\";\n\nexport function usePlugin(plugin: OnPlugin) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectPlugin(plugin);\n    return () => chief.removePlugin(plugin);\n  }, []);\n}\n","import { useEffect } from \"react\";\nimport { ChiefElement, InjectedRenderElement } from \"../chief\";\nimport { useChief } from \"./use-chief\";\n\nexport function useRenderElement<T extends ChiefElement = ChiefElement>(\n  ire: InjectedRenderElement<T>,\n  deps: any[] = []\n) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectRenderElement(ire);\n    return () => chief.removeRenderElement(ire);\n  }, deps);\n}\n","import { useEffect } from \"react\";\nimport { InjectedRenderLeaf } from \"../chief\";\nimport { useChief } from \"./use-chief\";\n\nexport function useRenderLeaf(irl: InjectedRenderLeaf, deps: any[] = []) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectRenderLeaf(irl);\n    return () => chief.removeRenderLeaf(irl);\n  }, deps);\n}\n","import styled from \"styled-components\";\nimport { OverrideTheme } from \"./override-theme\";\n\nexport const PlaceholderHint = styled.span<{\n  isEmpty: boolean;\n  placeholder?: string;\n  hoverHint?: string;\n}>`\n  display: inline-block;\n  width: 100%;\n  ::before {\n    filter: brightness(40%) invert(50%) opacity(0.2) grayscale(100%);\n    content: \"${props =>\n      props.isEmpty && props.placeholder && props.placeholder.length > 0\n        ? props.placeholder\n        : ``}\"\n;\n    pointer-events: none;\n    user-select: none;\n    position: absolute;\n  }\n  &:hover:before {\n    content: \"${props =>\n      props.isEmpty && props.hoverHint && !props.placeholder\n        ? props.hoverHint\n        : props.isEmpty && props.placeholder\n        ? props.placeholder\n        : \"\"}\";\n  }\n  ${props => OverrideTheme(\"PlaceholderHint\", props)}\n`;\n","import React, { memo, ReactNode } from \"react\";\nimport { RenderLeafProps } from \"slate-react\";\n\nexport function renderLeaf(\n  props: RenderLeafProps,\n  leafType: string,\n  rectType: any,\n  elementProps?: any\n) {\n  const { children, leaf } = props;\n  if (leaf[leafType]) {\n    return (\n      <Leaf {...props}>\n        {React.createElement(rectType, elementProps, children)}\n      </Leaf>\n    );\n  }\n  return undefined;\n}\n\nconst Leaf = (props: RenderLeafProps) => {\n  const { attributes, children } = props;\n  return <span {...attributes} children={children} />;\n};\n","import styled, { css } from \"styled-components\";\nimport { OverrideTheme } from \"../override-theme\";\n\nexport const uiStyle = css`\n  font-size: 14px;\n  font-family: Arial, Helvetica, sans-serif;\n  font-weight: normal;\n  a {\n    color: white !important;\n  }\n  ${props => OverrideTheme(\"ui\", props)}\n`;\n\nexport const UiWrap = styled.div`\n  ${uiStyle}\n`;\n","import styled from \"styled-components\";\nimport { OverrideTheme } from \"../override-theme\";\nimport { uiStyle } from \"./ui-wrap\";\nexport const ButtonBase = styled.button`\n  ${uiStyle}\n  line-height: 1.15;\n  margin: 0;\n  cursor: pointer;\n  &:focus {\n    outline: none;\n  }\n  ${props => OverrideTheme(\"ButtonBase\", props)}\n`;\n","import styled from \"styled-components\";\nimport { ButtonBase } from \"./button-base\";\nimport { OverrideTheme } from \"../override-theme\";\n\nexport const StyledToolbarBtn = styled<typeof ButtonBase>(ButtonBase)<{\n  isActive?: boolean;\n  rounded?: boolean;\n}>`\n  width: 100%;\n  transition: all 250ms;\n  background-color: white;\n  &:hover {\n    background-color: ${props =>\n      props.disabled ? undefined : props.theme.colors.gray[200]};\n  }\n  &:active {\n    background-color: ${props => props.theme.colors.gray[100]};\n  }\n  &:first-child {\n    padding-left: 10px;\n  }\n  &:last-child {\n    padding-right: 10px;\n  }\n  border-radius: ${props => (props.rounded ? \"5px\" : undefined)};\n  padding: 8px;\n  color: ${props => (props.isActive ? props.theme.colors.primary : undefined)};\n  border: none;\n  ${props => OverrideTheme(\"StyledToolbarBtn\", props)}\n`;\n","import React, { useRef, ReactNode, useState, useEffect } from \"react\";\nimport Overlay from \"react-overlays/Overlay\";\nimport { useGlobalHover, useHover } from \"./utils\";\nimport styled, { css } from \"styled-components\";\nimport { UiWrap } from \"./ui/ui-wrap\";\n\nexport function ElementHoverTip(\n  props: {\n    children:\n      | ReactNode\n      | ((\n          triggerRef: React.RefObject<HTMLDivElement>,\n          isHovering: boolean\n        ) => ReactNode);\n    tip?: ReactNode;\n    delayed?: boolean;\n  } & Omit<\n    React.ComponentProps<typeof Overlay>,\n    \"children\" | \"target\" | \"container\"\n  >\n) {\n  const containerRef = useRef(null);\n  const overlayRef = useRef(null);\n  const [triggerRef, isHovering] = useHover<HTMLDivElement>();\n  const isOverlayHovering = useGlobalHover(overlayRef.current);\n  const isOverlayHoveringRef = useRef(isOverlayHovering);\n  isOverlayHoveringRef.current = isOverlayHovering;\n  const isHoveringRef = useRef(isHovering);\n  isHoveringRef.current = isHovering;\n  const [show, setShow] = useState(isHovering);\n  useEffect(() => {\n    if (isHovering) {\n      setShow(true);\n    } else if (delayed) {\n      setTimeout(() => !isOverlayHoveringRef.current && setShow(false), 150);\n    } else {\n      setShow(false);\n    }\n  }, [isHovering]);\n  useEffect(() => {\n    if (!isOverlayHovering) {\n      setTimeout(() => !isHoveringRef.current && setShow(false), 150);\n    }\n  }, [isOverlayHovering]);\n  const { children, tip, delayed, ...overlayProps } = props;\n  const overlay = (\n    <Overlay\n      ref={overlayRef}\n      show={Boolean(tip) && show}\n      container={containerRef}\n      target={triggerRef}\n      {...overlayProps}\n    >\n      {({ props, arrowProps, placement }) => (\n        <Tooltip {...props} placement={placement}>\n          <Arrow\n            {...arrowProps}\n            placement={placement}\n            style={arrowProps.style}\n          />\n          <StyledTooltipBody>{tip}</StyledTooltipBody>\n        </Tooltip>\n      )}\n    </Overlay>\n  );\n  const container = (\n    <div\n      contentEditable={false}\n      style={{ position: \"absolute\", width: \"100%\" }}\n      ref={containerRef}\n    ></div>\n  );\n  if (typeof children === \"function\") {\n    return (\n      <React.Fragment>\n        {container}\n        {children(triggerRef, isHovering)}\n        {overlay}\n      </React.Fragment>\n    );\n  } else {\n    return (\n      <React.Fragment>\n        {container}\n        <span ref={triggerRef}>{children}</span>\n        {overlay}\n      </React.Fragment>\n    );\n  }\n}\n\nexport const StyledTooltipBody = styled(UiWrap)`\n  width: 100%;\n  font-size: 12px;\n  padding: 3px 8px;\n  color: #fff;\n  text-align: center;\n  border-radius: 3px;\n  background-color: #000;\n  div:nth-child(1) {\n  }\n  div:nth-child(2) {\n    font-weight: bold;\n    font-size: 0.7em;\n    color: ${props => props.theme.colors.gray[400]};\n  }\n`;\n\nexport const Arrow = styled.div<{ placement: string }>`\n  position: absolute;\n  width: 0;\n  height: 0;\n  border-style: solid;\n\n  ${p => {\n    switch (p.placement) {\n      case \"left\":\n        return css`\n          right: 0;\n          border-width: 5px 0 5px 5px;\n          border-color: transparent transparent transparent #000;\n        `;\n      case \"right\":\n        return css`\n          left: 0;\n          border-width: 5px 5px 5px 0;\n          border-color: transparent #232323 transparent transparent;\n        `;\n      case \"top\":\n        return css`\n          bottom: 0;\n          border-width: 5px 5px 0;\n          border-color: #232323 transparent transparent transparent;\n        `;\n      case \"bottom\":\n        return css`\n          top: 0;\n          border-width: 0 5px 5px;\n          border-color: transparent transparent #232323 transparent;\n        `;\n      default:\n        return \"\";\n    }\n  }}\n`;\n\nexport const Tooltip = styled.div<{ placement: string }>`\n  position: absolute;\n  padding: 0 5px;\n\n  ${p => {\n    switch (p.placement) {\n      case \"left\":\n        return css`\n          padding: 0 5px;\n        `;\n      case \"right\":\n        return css`\n          padding: 0 5px;\n        `;\n      case \"top\":\n        return css`\n          padding: 5px 0;\n        `;\n      case \"bottom\":\n        return css`\n          padding: 5px 0;\n        `;\n      default:\n        return \"\";\n    }\n  }}\n`;\n","import React, { ReactNode } from \"react\";\nimport { StyledToolbarBtn } from \"./ui/styled-toolbar-btn\";\nimport Overlay from \"react-overlays/Overlay\";\nimport { Label } from \"./chief/chief\";\nimport { useLabels } from \"./chief/hooks/use-labels\";\nimport { ElementHoverTip } from \"./element-hover-tip\";\nimport { ControlProps } from \"./chief/controls\";\nimport { useTheme } from \"styled-components\";\nimport { defaultTheme } from \"./defaultTheme\";\n\nexport type Ref = HTMLElement;\n\ntype Props = {\n  tooltip?: {\n    label: Label;\n    shortcut?: string;\n    placement?: React.ComponentProps<typeof Overlay>[\"placement\"];\n  };\n  onMouseDown?: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  onClick?: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n} & ControlProps &\n  Omit<React.ComponentProps<typeof StyledToolbarBtn>, \"children\">;\n\nexport const ToolbarBtn = React.forwardRef<Ref, Props>((props, ref) => {\n  const { onClick, onMouseDown, tooltip, children, ...otherProps } = props;\n  const [labels] = useLabels();\n  const theme = useTheme() as typeof defaultTheme;\n\n  return (\n    <ElementHoverTip\n      placement={tooltip?.placement ?? \"top\"}\n      tip={\n        tooltip && (\n          <React.Fragment>\n            <div>\n              <strong>{labels(tooltip.label)}</strong>\n            </div>\n            <div>{tooltip.shortcut}</div>\n          </React.Fragment>\n        )\n      }\n    >\n      <StyledToolbarBtn\n        // @ts-ignore\n        ref={ref}\n        onMouseDown={(e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n          if (onClick) {\n            onClick(e);\n            return;\n          }\n          onMouseDown && onMouseDown(e);\n        }}\n        {...otherProps}\n      >\n        {typeof children === \"function\"\n          ? // @ts-ignore\n            children({ isActive: props.isActive, theme })\n          : children}\n      </StyledToolbarBtn>\n    </ElementHoverTip>\n  );\n});\n","import React from \"react\";\nimport { useSlate } from \"slate-react\";\nimport { ToolbarBtn } from \"./ToolbarBtn\";\nimport { Editor, Transforms, Text } from \"slate\";\n\nexport function toggleFormat(editor: Editor, format: string) {\n  let isFormatted = isMark(editor, format);\n  Transforms.setNodes(\n    editor,\n    { [format]: !isFormatted },\n    { match: n => Text.isText(n), split: true }\n  );\n}\n\nconst isMark = (editor: Editor, formatType: string) => {\n  const [match] = Editor.nodes(editor, {\n    match: n => Boolean(n[formatType])\n  });\n  return Boolean(match);\n};\n\nexport function MarkBtn(\n  props: {\n    markType: string;\n  } & React.ComponentProps<typeof ToolbarBtn>\n) {\n  const { markType: formatType, ...otherProps } = props;\n  const editor = useSlate();\n  const isActive = isMark(editor, props.markType);\n  return (\n    <ToolbarBtn\n      isActive={isActive}\n      onMouseDown={(e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n        e.preventDefault();\n        toggleFormat(editor, props.markType);\n      }}\n      {...otherProps}\n    />\n  );\n}\n","import { toKeyName } from \"is-hotkey\";\n\nexport function shortcutText(shortcut: string) {\n  return toKeyName(shortcut).replace(\"mod\", \"\").toUpperCase();\n}\n","import { ReactNode } from \"react\";\nimport { Editor as SlateEditor } from \"slate\";\nimport { defaultTheme } from \"../../defaultTheme\";\nimport { useSlate } from \"slate-react\";\nimport { ChiefElement, ElementTypeMatch, isChiefElement } from \"../chief\";\nimport { matchesType } from \"../utils/matches-type\";\n\nexport function useIsControlEligable(opts: {\n  typeMatch?: ElementTypeMatch;\n  isVoid?: boolean;\n  isText?: boolean;\n  isEmpty?: boolean;\n}) {\n  const editor = useSlate();\n  const { selection } = editor;\n  if (selection) {\n    const [match] = SlateEditor.nodes(editor, {\n      at: selection,\n      voids: opts.isVoid,\n      match: n => {\n        // console.log(n && SlateEditor.isEmpty(editor, n as ChiefElement));\n        if (opts.typeMatch && typeof n.type === \"string\") {\n          if (matchesType(n as ChiefElement, opts.typeMatch)) {\n            return true;\n          }\n        } else if (\n          typeof opts.isVoid === \"boolean\" &&\n          opts.isVoid === SlateEditor.isVoid(editor, n)\n        ) {\n          return true;\n        } else if (\n          opts.isEmpty &&\n          isChiefElement(n) &&\n          SlateEditor.isEmpty(editor, n)\n        ) {\n          return true;\n        } else if (\n          opts.isText &&\n          SlateEditor.string(editor, selection).length > 0\n        ) {\n          return true;\n        }\n        return false;\n      }\n    });\n    return Boolean(match);\n  }\n  return false;\n}\n\nexport type RenderControlProps = {\n  isActive: boolean;\n  theme: typeof defaultTheme;\n};\nexport type ControlChildrenProp =\n  | ((props: RenderControlProps) => ReactNode)\n  | ReactNode;\nexport type ControlProps = {\n  children: ControlChildrenProp;\n};\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { MarkBtn, toggleFormat } from \"../../mark-button\";\nimport { useRenderLeaf } from \"../../chief/hooks/use-render-leaf\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { shortcutText } from \"../../shortcut\";\nimport { InjectedRenderLeaf } from \"../../chief\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nconst shortcut = \"mod+i\";\n\nexport function ItalicControl(props: ControlProps) {\n  if (\n    !useIsControlEligable({\n      isText: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <MarkBtn\n      tooltip={{\n        label: {\n          key: \"marks.italic\",\n          defaultLabel: \"Italic\"\n        },\n        shortcut: shortcutText(shortcut)\n      }}\n      markType=\"italic\"\n    >\n      {props.children}\n    </MarkBtn>\n  );\n}\n\nconst _renderLeaf: InjectedRenderLeaf = {\n  renderLeaf: props => renderLeaf(props, \"italic\", \"em\")\n};\n\nconst Presenter: iPresenter = {\n  leaf: _renderLeaf\n};\n\nexport function ItalicAddon(props: AddonProps) {\n  useLabels(props.labels);\n  useRenderLeaf(_renderLeaf);\n  useOnKeyDown({\n    pattern: shortcut,\n    handler: (event, editor) => {\n      event.preventDefault();\n      toggleFormat(editor, \"italic\");\n      return true;\n    }\n  });\n  return null;\n}\n\nItalicAddon.Presenter = Presenter;\n","import React, { ReactNode } from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { MarkBtn, toggleFormat } from \"../../mark-button\";\nimport { useRenderLeaf } from \"../../chief/hooks/use-render-leaf\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { InjectedRenderLeaf } from \"../../chief\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\nimport { shortcutText } from \"../../shortcut\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nconst shortcut = \"mod+u\";\n\nexport function UnderlineControl(props: ControlProps) {\n  if (\n    !useIsControlEligable({\n      isText: true,\n      isEmpty: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <MarkBtn\n      tooltip={{\n        label: {\n          key: \"marks.underline\",\n          defaultLabel: \"Underline\"\n        },\n        shortcut: shortcutText(shortcut)\n      }}\n      markType=\"underline\"\n    >\n      {props.children}\n    </MarkBtn>\n  );\n}\n\nconst _renderLeaf: InjectedRenderLeaf = {\n  renderLeaf: props => renderLeaf(props, \"underline\", \"u\")\n};\n\nconst Presenter: iPresenter = {\n  leaf: _renderLeaf\n};\n\nexport function UnderlineAddon(props: AddonProps) {\n  useLabels(props.labels);\n  useRenderLeaf(_renderLeaf);\n  useOnKeyDown({\n    pattern: shortcut,\n    handler: (event, editor) => {\n      event.preventDefault();\n      toggleFormat(editor, \"underline\");\n      return true;\n    }\n  });\n  return null;\n}\n\nUnderlineAddon.Presenter = Presenter;\n","import React, { ReactNode } from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { MarkBtn, toggleFormat } from \"../../mark-button\";\nimport { useRenderLeaf } from \"../../chief/hooks/use-render-leaf\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { shortcutText } from \"../../shortcut\";\nimport { InjectedRenderLeaf } from \"../../chief\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nconst shortcut = \"mod+s\";\n\nexport function StrikethroughControl(props: ControlProps) {\n  if (\n    !useIsControlEligable({\n      isText: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <MarkBtn\n      tooltip={{\n        label: {\n          key: \"marks.strikethrough\",\n          defaultLabel: \"Strike-through\"\n        },\n        shortcut: shortcutText(shortcut)\n      }}\n      markType=\"strikethrough\"\n    >\n      {props.children}\n    </MarkBtn>\n  );\n}\n\nconst _renderLeaf: InjectedRenderLeaf = {\n  renderLeaf: props => renderLeaf(props, \"strikethrough\", \"s\")\n};\n\nconst Presenter: iPresenter = {\n  leaf: _renderLeaf\n};\n\nexport function StrikethroughAddon(props: AddonProps) {\n  useLabels(props.labels);\n  useRenderLeaf(_renderLeaf);\n  useOnKeyDown({\n    pattern: shortcut,\n    handler: (event, editor) => {\n      event.preventDefault();\n      toggleFormat(editor, \"strikethrough\");\n      return true;\n    }\n  });\n  return null;\n}\n\nStrikethroughAddon.Presenter = Presenter;\n","import React from \"react\";\nimport { useFocused, useSelected, useEditor } from \"slate-react\";\nimport { PlaceholderHint } from \"../../placeholder-hint\";\nimport { Editor } from \"slate\";\nimport { useLabels, ChiefRenderElementProps } from \"../../chief\";\n\nexport const Heading = (props: ChiefRenderElementProps) => {\n  const editor = useEditor();\n  const isFocused = useFocused();\n  const isSelected = useSelected();\n  const defaultPlaceholderTexts = {\n    h1: \"Heading 1\",\n    h2: \"Heading 2\",\n    h3: \"Heading 3\",\n    h4: \"Heading 4\",\n    h5: \"Heading 5\",\n    h6: \"Heading 6\"\n  };\n  const [getLabel] = useLabels();\n  let placeholder = getLabel({\n    key: `elements.heading.${props.element.type}.placeholder`,\n    defaultLabel: defaultPlaceholderTexts[props.element.type]\n  });\n\n  return React.createElement(\n    props.element.type,\n    props.attributes,\n    <PlaceholderHint\n      isEmpty={Editor.isEmpty(editor, props.element)}\n      placeholder={isFocused && isSelected ? placeholder : undefined}\n    >\n      {props.children}\n    </PlaceholderHint>\n  );\n};\n","import React, { ReactNode } from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { Heading } from \"./Heading\";\nimport { Transforms, Editor, Range, Element } from \"slate\";\nimport { useSlate, ReactEditor } from \"slate-react\";\nimport { isNodeActive } from \"../../utils\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { RichEditor } from \"../../chief/editor\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nexport const headingTypes = [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"] as const;\n\nexport function HeadingControl(\n  props: {\n    heading: typeof headingTypes[number];\n  } & ControlProps\n) {\n  const { heading, children } = props;\n  const editor = useSlate();\n  if (\n    !useIsControlEligable({\n      isText: true,\n      isEmpty: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <ToolbarBtn\n      tooltip={{\n        label: {\n          key: `elements.heading.${heading}.placeholder`,\n          defaultLabel: heading\n        }\n      }}\n      isActive={isNodeActive(editor, heading)}\n      onMouseDown={(_e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n        ReactEditor.focus(editor);\n        RichEditor.insertBlock(editor, heading);\n      }}\n    >\n      {children || heading.toUpperCase()}\n    </ToolbarBtn>\n  );\n}\n\nconst Presenter: iPresenter = {\n  element: {\n    typeMatch: headingTypes,\n    renderElement: props =>\n      React.createElement(props.element.type, null, props.children)\n  }\n};\n\nexport function HeadingsAddon(_props: AddonProps) {\n  useRenderElement({\n    typeMatch: headingTypes,\n    renderElement: props => <Heading {...props} />\n  });\n  useOnKeyDown({\n    pattern: \"Enter\",\n    handler: (event, editor) => {\n      const { selection } = editor;\n      if (selection && Range.isCollapsed(selection)) {\n        const [match] = Editor.nodes(editor, {\n          match: n =>\n            typeof n.type === \"string\" && Boolean(n.type?.match(/(h[1-6])/))\n        });\n        if (match) {\n          event.preventDefault();\n          const [node] = match;\n          if (Element.isElement(node) && Editor.isEmpty(editor, node)) {\n            Transforms.setNodes(editor, { type: \"paragraph\" });\n          } else {\n            Transforms.insertNodes(editor, {\n              type: \"paragraph\",\n              children: [{ text: \"\" }]\n            });\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n  });\n  return null;\n}\n\nfunction toggleHeading(editor: Editor, heading: string) {\n  const isHeaderOfType = isHeadingType(editor, heading);\n  if (isHeaderOfType) {\n    Transforms.setNodes(editor, {\n      type: \"paragraph\"\n    });\n  } else {\n    Transforms.setNodes(editor, {\n      type: heading\n    });\n  }\n}\n\nexport const isHeadingType = (editor: Editor, header: string) => {\n  const [match] = Editor.nodes(editor, {\n    match: n => n.type === header\n  });\n  return Boolean(match);\n};\n\nfunction insertHeader(editor: Editor, heading: string) {\n  Transforms.insertNodes(editor, {\n    type: heading,\n    children: [{ text: \"\" }]\n  });\n}\n\nfunction HeadingBtn(props: { headingType: string; children: React.ReactNode }) {\n  const editor = useSlate();\n  const isActive = isHeadingType(editor, props.headingType);\n  return (\n    <ToolbarBtn\n      isActive={isActive}\n      onMouseDown={(e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n        e.preventDefault();\n        toggleHeading(editor, props.headingType);\n      }}\n    >\n      {props.children}\n    </ToolbarBtn>\n  );\n}\n\nHeadingsAddon.Presenter = Presenter;\n","import { AddonProps } from \"../../addon\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { Range } from \"slate\";\n\nexport function PreventNewlineAddon(props: AddonProps) {\n  useOnKeyDown({\n    pattern: \"enter+shift\",\n    handler: (event, editor) => {\n      if (editor.selection && Range.isCollapsed(editor.selection)) {\n        event.preventDefault();\n        event.stopPropagation();\n        editor.insertText(\"\\n\");\n        return true;\n      }\n      return false;\n    }\n  });\n  return null;\n}\n","import { Editor, Transforms, Range } from \"slate\";\nimport { usePlugin } from \"../../chief/hooks/use-plugin\";\n\nexport function ResetToParagraphAddon() {\n  usePlugin({\n    deleteBackward: (deleteBackward, editor) => (...args) => {\n      const { selection } = editor;\n      if (selection && Range.isCollapsed(selection)) {\n        const [parent, path] = Editor.parent(editor, selection);\n        const isParagraph = parent.type === \"paragraph\";\n        if (\n          path.length === 1 &&\n          !isParagraph &&\n          selection &&\n          selection.focus.offset === 0\n        ) {\n          return Transforms.setNodes(editor, { type: \"paragraph\" });\n        }\n      }\n      return deleteBackward(...args);\n    }\n  });\n  return null;\n}\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\n\nexport function LabelsAddon(props: Pick<AddonProps, \"labels\">) {\n  useLabels(props.labels);\n  return null;\n}\n","import React from \"react\";\nimport { Editor as SlateEditor, Range } from \"slate\";\nimport {\n  RenderElementProps,\n  useFocused,\n  useSelected,\n  useSlate\n} from \"slate-react\";\nimport { PlaceholderHint } from \"../../placeholder-hint\";\nimport { ChiefRenderElementProps } from \"../../chief/chief\";\n\nexport function ParagraphElement(\n  props: ChiefRenderElementProps & { placeholder?: string; hint?: string }\n) {\n  const editor = useSlate();\n  const isFocused = useFocused();\n  const isSelected = useSelected();\n  return (\n    <p {...props.attributes}>\n      <PlaceholderHint\n        isEmpty={SlateEditor.isEmpty(editor, props.element)}\n        hoverHint={props.hint}\n        placeholder={isFocused && isSelected ? props.placeholder : undefined}\n      >\n        {React.Children.map(props.children, it => it)}\n      </PlaceholderHint>\n    </p>\n  );\n}\n","import React, { ReactNode } from \"react\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { ParagraphElement } from \"./paragraph-element\";\nimport { useLabels, ElementTypeMatch, RichEditor } from \"../../chief\";\nimport { AddonProps } from \"../../addon\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { isNodeActive } from \"../../utils\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nconst TYPE: ElementTypeMatch = \"paragraph\";\n\nexport function ParagraphControl(props: ControlProps) {\n  const editor = useSlate();\n  if (\n    !useIsControlEligable({\n      isText: true,\n      isEmpty: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <ToolbarBtn\n      tooltip={{\n        label: {\n          key: `elements.paragraph.placeholder`,\n          defaultLabel: \"Paragraph\"\n        }\n      }}\n      isActive={isNodeActive(editor, \"paragraph\")}\n      onMouseDown={() => {\n        RichEditor.insertBlock(editor, \"paragraph\");\n        ReactEditor.focus(editor);\n      }}\n    >\n      {props.children}\n    </ToolbarBtn>\n  );\n}\n\nexport function ParagraphAddon({\n  showHint = true,\n  showPlaceholder = true,\n  labels\n}: {\n  showHint?: boolean;\n  showPlaceholder?: boolean;\n} & AddonProps) {\n  const [getLabel] = useLabels(labels);\n  useRenderElement(\n    {\n      typeMatch: TYPE,\n      renderElement: props => (\n        <ParagraphElement\n          hint={\n            showHint\n              ? getLabel({\n                  key: \"elements.paragraph.hint\",\n                  defaultLabel: \"Click to start typing\"\n                })\n              : undefined\n          }\n          placeholder={\n            showPlaceholder\n              ? getLabel({\n                  key: \"elements.paragraph.placeholder\",\n                  defaultLabel: \"Text\"\n                })\n              : undefined\n          }\n          {...props}\n        ></ParagraphElement>\n      )\n    },\n    [getLabel]\n  );\n  return null;\n}\n\nconst ParagraphPresenter: iPresenter = {\n  element: {\n    typeMatch: TYPE,\n    renderElement: props => <p>{props.children}</p>\n  }\n};\n\nParagraphAddon.Presenter = ParagraphPresenter;\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { useRenderLeaf } from \"../../chief/hooks/use-render-leaf\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { MarkBtn, toggleFormat } from \"../../mark-button\";\nimport { shortcutText } from \"../../shortcut\";\nimport { ReactEditor } from \"slate-react\";\nimport { InjectedRenderLeaf } from \"../../chief\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nconst shortcut = \"mod+b\";\n\nconst action = (editor: ReactEditor) => toggleFormat(editor, \"bold\");\n\nconst _renderLeaf: InjectedRenderLeaf = {\n  renderLeaf: props => renderLeaf(props, \"bold\", \"strong\")\n};\n\nexport function BoldAddon(props: AddonProps) {\n  // useAddonAction(\"bold\", action);\n\n  // const boldToggle = useAddonAction(\"bold\");\n\n  useLabels(props.labels);\n  useRenderLeaf(_renderLeaf);\n  useOnKeyDown({\n    pattern: shortcut,\n    handler: (event, editor) => {\n      event.preventDefault();\n      action(editor);\n      return true;\n    }\n  });\n  return null;\n}\n\nconst Presenter: iPresenter = {\n  leaf: _renderLeaf\n};\n\nexport function BoldControl(props: ControlProps) {\n  if (\n    !useIsControlEligable({\n      isText: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <MarkBtn\n      tooltip={{\n        label: {\n          key: \"marks.bold\",\n          defaultLabel: \"Bold\"\n        },\n        shortcut: shortcutText(shortcut)\n      }}\n      markType=\"bold\"\n    >\n      {props.children}\n    </MarkBtn>\n  );\n}\n\nBoldAddon.Presenter = Presenter;\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst HiddenFileInput = styled.input.attrs({\n  type: \"file\"\n})`\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute !important;\n  white-space: nowrap;\n  width: 1px;\n`;\n\nexport const FileUpload = React.forwardRef<\n  HTMLInputElement,\n  Omit<React.InputHTMLAttributes<HTMLInputElement>, \"type\" | \"id\">\n>((props, ref) => <HiddenFileInput ref={ref} {...props} />);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isPresent(t) {\n    return t !== undefined && t !== null;\n}\nexports.isPresent = isPresent;\nfunction isDefined(t) {\n    return t !== undefined;\n}\nexports.isDefined = isDefined;\nfunction isFilled(t) {\n    return t !== null;\n}\nexports.isFilled = isFilled;\n//# sourceMappingURL=index.js.map","import React, { Fragment, ReactNode } from \"react\";\n\nexport const Show = (props: {\n  when: any | undefined | null;\n  children: ReactNode;\n}) => {\n  const { when, children } = props;\n  if (!Boolean(when)) {\n    return null;\n  }\n  return <Fragment>{children}</Fragment>;\n};\n","import React, { useState } from \"react\";\nimport { RenderElementProps } from \"slate-react\";\nimport { useFocused } from \"./Focused\";\nimport { Show } from \"./show\";\nimport { useChief } from \"./chief/hooks/use-chief\";\n\nexport function ElementWrapper(\n  props: RenderElementProps & {\n    attentionChildren?: React.ReactNode;\n    style?: React.CSSProperties;\n  }\n) {\n  const {\n    children,\n    element,\n    attentionChildren,\n    style,\n    attributes,\n    ...otherProps\n  } = props;\n  const { isFocusedWithin } = useFocused(element);\n  const [inside, setInside] = useState(false);\n  const { readOnly } = useChief();\n  const handleEnter = () => {\n    !readOnly && setInside(true);\n  };\n  const handleLeave = () => {\n    setInside(false);\n  };\n  return (\n    <div\n      data-slate-zero-width=\"z\"\n      onMouseEnter={handleEnter}\n      onMouseLeave={handleLeave}\n      style={{ position: \"relative\" }}\n      {...otherProps}\n    >\n      <Show when={!readOnly && (isFocusedWithin || inside)}>\n        <div style={{ position: \"absolute\", zIndex: 2, ...style }}>\n          {attentionChildren}\n        </div>\n      </Show>\n      {children}\n    </div>\n  );\n}\n","import { Node, Path } from \"slate\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { useState, useEffect } from \"react\";\n\nexport const useFocused = (node?: Node) => {\n  const editor = useSlate();\n  const { selection } = editor;\n  const [focus, setFocus] = useState({\n    isFocused: false,\n    isFocusedWithin: false\n  });\n  useEffect(() => {\n    if (!node) {\n      return;\n    }\n    const path = ReactEditor.findPath(editor, node);\n    let isFocused = false;\n    let isFocusedWithin = false;\n    if (selection) {\n      const { focus } = selection;\n      isFocusedWithin = Path.isDescendant(focus.path, path);\n      isFocused = Path.equals(focus.path, path);\n    }\n    setFocus({ isFocused, isFocusedWithin });\n  }, [node, selection]);\n\n  return focus;\n};\n","import styled from \"styled-components\";\nexport const ToolsWrapper = styled.div`\n  display: flex;\n  align-items: center;\n`;\n","import styled from \"styled-components\";\nimport { OverrideTheme } from \"./override-theme\";\nimport { UiWrap } from \"./ui/ui-wrap\";\n\nexport const StyledToolBase = styled(UiWrap)`\n  overflow: hidden;\n  border-radius: 3px;\n  box-shadow: rgba(15, 15, 15, 0.05) 0px 0px 0px 1px,\n    rgba(15, 15, 15, 0.1) 0px 3px 6px, rgba(15, 15, 15, 0.2) 0px 9px 24px;\n`;\n\nexport const StyledToolBox = styled(StyledToolBase)`\n  background-color: white;\n  ${props => OverrideTheme(\"StyledToolBox\", props)}\n`;\n","import styled from \"styled-components\";\nimport { StyledToolBase } from \"../StyledToolBox\";\nimport { ButtonBase } from \"./button-base\";\n\nexport const StyledFocusToolBtn = styled(ButtonBase)`\n  background-color: rgba(47, 47, 47, 0.67);\n  &:hover {\n    background-color: rgba(67, 67, 67, 0.67);\n  }\n  color: white;\n  border: none;\n  &:first-child {\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px;\n  }\n  &:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px;\n  }\n  padding: 4px 8px;\n  margin: 0 1px;\n`;\n\nexport const StyledFocusToolbar = styled(StyledToolBase)`\n  background-color: transparent;\n`;\n","import React from \"react\";\nimport { RenderElementProps } from \"slate-react\";\nimport { ElementWrapper } from \"../element-wrapper\";\nimport { ToolsWrapper } from \"../ToolsWrapper\";\nimport { StyledFocusToolbar } from \"./StyledFocusToolbar\";\n\nexport function WithAttentionToolbar(\n  props: RenderElementProps & {\n    children: React.ReactNode;\n    btns: React.ReactNode;\n  }\n) {\n  const { btns, children, ...renderElementProps } = props;\n  return (\n    <ElementWrapper\n      {...renderElementProps}\n      attentionChildren={\n        <StyledFocusToolbar>\n          <ToolsWrapper>{btns}</ToolsWrapper>\n        </StyledFocusToolbar>\n      }\n      style={{ right: 0, marginTop: 5, marginRight: 5 }}\n    >\n      {children}\n    </ElementWrapper>\n  );\n}\n","import styled from \"styled-components\";\n\nexport const Input = styled.input.attrs(props => ({}))`\n  &:focus {\n    outline: 0;\n  }\n  font-size: inherit;\n  line-height: inherit;\n  border: none;\n  background: none;\n  width: 100%;\n  display: block;\n  resize: none;\n  padding: 0px;\n`;\n\nexport const InputWrapper = styled.div.attrs(props => ({\n  \"data-slate-editor\": true\n}))`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  font-size: 14px;\n  line-height: 20px;\n  padding: 4px 10px;\n  position: relative;\n  border-radius: 3px;\n  box-shadow: rgba(15, 15, 15, 0.1) 0px 0px 0px 1px inset,\n    rgba(15, 15, 15, 0.1) 0px 1px 1px inset;\n  background: rgba(242, 241, 238, 0.6);\n  cursor: text;\n  flex-grow: 1;\n  flex-shrink: 1;\n  margin-right: 8px;\n  ${Input} {\n  }\n`;\n","import styled from \"styled-components\";\nimport { ButtonBase } from \"./button-base\";\n\nexport const Button = styled(ButtonBase)`\n  background-color: ${props => props.theme.colors.primary};\n  :hover {\n    filter: brightness(85%);\n  }\n  :active {\n    filter: brightness(75%);\n  }\n  :disabled {\n    background-color: ${props => props.theme.colors.gray[400]};\n    color: ${props => props.theme.colors.gray[500]};\n  }\n  color: white;\n  border-radius: 0;\n  border: none;\n  padding: 4px 8px;\n`;\n","import React, { useState, useRef } from \"react\";\nimport { Popper, Manager, Reference } from \"react-popper\";\nimport { useOnClickOutside } from \"./utils\";\nimport { useOnKeyDown } from \"./chief\";\n\nexport function ToolBtnPopup(props: {\n  shortcut?: string;\n  renderContent: (setShow: (show: boolean) => void) => React.ReactNode;\n  renderToolBtn: (\n    props: {\n      ref: React.Ref<any>;\n      onMouseDown: (e: React.MouseEvent) => void;\n    },\n    show: boolean\n  ) => React.ReactNode;\n}) {\n  const [show, setShow] = useState(false);\n  const toolWindow = useRef(null);\n  useOnClickOutside(toolWindow, e => {\n    if (!e.defaultPrevented) {\n      setShow(false);\n    }\n    e.preventDefault();\n  });\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n    if (e.keyCode === 27) {\n      setShow(false);\n    }\n  };\n  useOnKeyDown({\n    pattern: props.shortcut,\n    handler: () => setShow(!show)\n  });\n  return (\n    <Manager>\n      <Reference>\n        {({ ref }) =>\n          props.renderToolBtn(\n            {\n              ref,\n              onMouseDown: e => {\n                e.preventDefault();\n                setShow(!show);\n              }\n            },\n            show\n          )\n        }\n      </Reference>\n      <Popper\n        placement=\"bottom-start\"\n        modifiers={[\n          {\n            name: \"offset\",\n            options: {\n              offset: [-100, 10]\n            }\n          }\n        ]}\n      >\n        {({ ref, style, placement, arrowProps }) => (\n          <div ref={ref} style={style} data-placement={placement}>\n            {show && (\n              <div onKeyDown={handleKeyDown} ref={toolWindow}>\n                {props.renderContent(setShow)}\n              </div>\n            )}\n            <div ref={arrowProps.ref} style={arrowProps.style} />\n          </div>\n        )}\n      </Popper>\n    </Manager>\n  );\n}\n","import React, { useState, useCallback, useEffect } from \"react\";\nimport { Transforms } from \"slate\";\nimport { useFocused, useSelected, ReactEditor, useSlate } from \"slate-react\";\nimport { WithAttentionToolbar } from \"../../ui/WithAttentionToolbar\";\nimport { Input, InputWrapper } from \"../../InputWrapper\";\nimport isUrl from \"is-url\";\nimport { ImageElement } from \"./index\";\nimport { Button } from \"../../ui/button\";\nimport styled from \"styled-components\";\nimport { ToolBtnPopup } from \"../../ToolBtnPopup\";\nimport { StyledToolBox } from \"../../StyledToolBox\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { StyledFocusToolBtn } from \"../../ui/StyledFocusToolbar\";\nimport { ChiefRenderElementProps } from \"../../chief/chief\";\nimport { UiWrap } from \"../../ui/ui-wrap\";\nimport ReactResizeDetector from \"react-resize-detector/lib/\";\nimport { useChief } from \"../../chief/hooks/use-chief\";\n\nexport const ImageBlock = (\n  props: ChiefRenderElementProps<ImageElement> & {\n    onOpenFileRequest?: () => void;\n    onRemoved?: (url: string | null) => void;\n  }\n) => {\n  const focused = useFocused();\n  const selected = useSelected();\n  const editor = useSlate();\n  const { readOnly } = useChief();\n  const { onOpenFileRequest, onRemoved, ...renderElementProps } = props;\n  const { element, children, attributes } = renderElementProps;\n\n  const [embedUrl, setEmbedUrl] = useState(element.url || \"\");\n  const [isReplacing, setIsReplacing] = useState(false);\n\n  const handleSubmitEmbed = useCallback(\n    (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault();\n      if (embedUrl.length > 0) {\n        Transforms.setNodes(\n          editor,\n          {\n            url: embedUrl,\n            align: \"center\"\n          },\n          {\n            at: ReactEditor.findPath(editor, element)\n          }\n        );\n        if (isReplacing) {\n          setIsReplacing(false);\n        }\n      }\n    },\n    [embedUrl, isReplacing]\n  );\n\n  useEffect(() => {\n    if (element.url && isReplacing) {\n      setIsReplacing(false);\n    }\n  }, [element.url]);\n\n  const handleDelete = useCallback(() => {\n    onRemoved && onRemoved(element.url);\n    Transforms.delete(editor, { at: ReactEditor.findPath(editor, element) });\n  }, [element]);\n\n  const handleUpload = useCallback(() => {\n    onOpenFileRequest && onOpenFileRequest();\n  }, [onOpenFileRequest]);\n\n  const handleResize = useCallback((w, h) => {\n    Transforms.setNodes(\n      editor,\n      {\n        width: w,\n        height: h\n      },\n      {\n        at: ReactEditor.findPath(editor, element)\n      }\n    );\n  }, []);\n\n  const align = useCallback((align: ImageElement[\"align\"]) => {\n    Transforms.setNodes(\n      editor,\n      {\n        align\n      },\n      {\n        at: ReactEditor.findPath(editor, element)\n      }\n    );\n  }, []);\n\n  const toggleReplace = useCallback(() => {\n    setIsReplacing(!isReplacing);\n  }, [isReplacing]);\n\n  const handleClick = () => {\n    Transforms.select(editor, ReactEditor.findPath(editor, element));\n  };\n\n  let imageHandler = null;\n\n  if (!isReplacing && element.url) {\n    const src = element.url || \"\";\n    imageHandler = (\n      <WithAttentionToolbar\n        {...renderElementProps}\n        btns={\n          <React.Fragment>\n            <StyledFocusToolBtn onMouseDown={handleDelete}>\n              Delete\n            </StyledFocusToolBtn>\n            <ToolBtnPopup\n              renderContent={() => (\n                <StyledToolBox>\n                  {/* <ToolbarBtn>Copy address</ToolbarBtn> */}\n                  {/* <ToolbarBtn>Resize</ToolbarBtn> */}\n                  <ToolbarBtn onMouseDown={toggleReplace}>Replace</ToolbarBtn>\n                  <ToolbarBtn onMouseDown={() => align(\"left\")}>\n                    Align left\n                  </ToolbarBtn>\n                  <ToolbarBtn onMouseDown={() => align(\"center\")}>\n                    Align center\n                  </ToolbarBtn>\n                  <ToolbarBtn onMouseDown={() => align(\"right\")}>\n                    Align right\n                  </ToolbarBtn>\n                </StyledToolBox>\n              )}\n              renderToolBtn={tprops => (\n                <StyledFocusToolBtn {...tprops}>...</StyledFocusToolBtn>\n              )}\n            ></ToolBtnPopup>\n          </React.Fragment>\n        }\n      >\n        <div\n          style={{\n            position: \"relative\",\n            height: element.height,\n            display: \"flex\",\n            justifyContent:\n              props.element.align === \"center\"\n                ? \"center\"\n                : props.element.align === \"left\"\n                ? \"flex-start\"\n                : \"flex-end\"\n          }}\n          contentEditable={false}\n          onClick={handleClick}\n        >\n          <ReactResizeDetector\n            onResize={(w: number, h: number) => handleResize(w, h)}\n          >\n            <div\n              style={{\n                resize: readOnly ? \"none\" : \"both\",\n                overflow: \"auto\",\n                width: element.width,\n                height: element.height\n              }}\n            >\n              <img\n                draggable={false}\n                style={{\n                  objectFit: \"fill\",\n                  width: \"100%\",\n                  height: \"100%\",\n                  display: \"block\"\n                }}\n                alt={element.caption}\n                src={src}\n              />\n            </div>\n          </ReactResizeDetector>\n        </div>\n        {children}\n      </WithAttentionToolbar>\n    );\n  } else {\n    imageHandler = (\n      <WithAttentionToolbar\n        {...renderElementProps}\n        btns={\n          <React.Fragment>\n            <StyledFocusToolBtn onMouseDown={handleDelete}>\n              Delete\n            </StyledFocusToolBtn>\n            {isReplacing && (\n              <StyledFocusToolBtn onMouseDown={toggleReplace}>\n                Cancel\n              </StyledFocusToolBtn>\n            )}\n          </React.Fragment>\n        }\n      >\n        <div contentEditable={false}>\n          <StyledImageEmptyContainer>\n            <h2>Insert image</h2>\n            <Button onMouseDown={handleUpload}>Upload</Button>\n            <p>Or paste a link</p>\n            <form onSubmit={handleSubmitEmbed} data-slate-editor>\n              <InputWrapper style={{ width: \"50%\" }}>\n                <Input\n                  value={embedUrl}\n                  onChange={e => setEmbedUrl(e.target.value)}\n                  placeholder=\"Paste link\"\n                ></Input>\n              </InputWrapper>\n              <br />\n              <Button disabled={embedUrl.length === 0 || !isUrl(embedUrl)}>\n                Embed\n              </Button>\n            </form>\n            {children}\n          </StyledImageEmptyContainer>\n        </div>\n      </WithAttentionToolbar>\n    );\n  }\n\n  return (\n    <div\n      style={{\n        outline: focused && selected ? \"1px solid rgb(46, 170, 220)\" : \"none\"\n      }}\n      {...attributes}\n      contentEditable={false}\n    >\n      {imageHandler}\n    </div>\n  );\n};\n\nexport const StyledImageEmptyContainer = styled(UiWrap)`\n  background-color: ${props => props.theme.colors.gray[300]};\n  padding: 8px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  form {\n    width: 70%;\n    display: flex;\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n  }\n  h2,\n  p {\n    color: ${props => props.theme.colors.gray[600]};\n    user-select: none;\n  }\n`;\n","import {} from \"./image-element\";\nimport React, { useRef, useEffect, ReactNode } from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { Editor, Transforms } from \"slate\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { isNodeActive, getNodeFromSelection, findNodes } from \"../../utils\";\nimport { RichEditor } from \"../../chief/editor\";\nimport { FileUpload } from \"../../FileUpload\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { ChiefElement, isChiefElement } from \"../../chief/chief\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { usePlugin } from \"../../chief/hooks/use-plugin\";\nimport { isDefined, isFilled } from \"ts-is-present\";\nimport { HistoryEditor } from \"slate-history\";\nimport isUrl from \"is-url\";\nimport { ImageExtensions } from \"./ImageExtensions\";\nimport { ImageBlock } from \"./image-element\";\nimport { iPresenter } from \"../../chief\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nexport interface ImageElement extends ChiefElement {\n  type: \"image\";\n  url: string | null;\n  caption?: string;\n  previewId?: number;\n  width: number;\n  height: number;\n  align: \"left\" | \"center\" | \"right\";\n}\n\nexport function isImageElement(element: unknown): element is ImageElement {\n  return isChiefElement(element) && element.type === \"image\";\n}\n\nexport function ImageControl(props: ControlProps) {\n  const editor = useSlate();\n  if (\n    !useIsControlEligable({\n      isText: true,\n      isEmpty: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <ToolbarBtn\n      tooltip={{\n        label: {\n          key: `elements.image`,\n          defaultLabel: \"Image\"\n        }\n      }}\n      isActive={isNodeActive(editor, \"image\")}\n      onClick={() => {\n        RichEditor.insertBlock(editor, \"image\");\n        ReactEditor.focus(editor);\n      }}\n    >\n      {props.children}\n    </ToolbarBtn>\n  );\n}\n\nexport const isImageUrl = (url: string, extensions = ImageExtensions) => {\n  if (!url) return false;\n  if (!isUrl(url)) return false;\n  const ext = new URL(url).pathname.split(\".\").pop() as string;\n  return extensions.includes(ext);\n};\n\nconst insertImage = (editor: ReactEditor, url: string) => {\n  const image = { type: \"image\", url, children: [{ text: \"\" }] };\n  Transforms.insertNodes(editor, image);\n};\n\nfunction getAllImageNodes(editor: Editor) {\n  const [...images] = findNodes(editor, n => n.type === \"image\");\n  return images.map(([node]) => node) as ImageElement[];\n}\n\nconst Presenter: iPresenter<ImageElement> = {\n  element: {\n    typeMatch: \"image\",\n    renderElement: props => (\n      <div\n        style={{\n          display: \"flex\",\n          justifyContent:\n            props.element.align === \"center\"\n              ? \"center\"\n              : props.element.align === \"left\"\n              ? \"flex-start\"\n              : \"flex-end\"\n        }}\n      >\n        <img\n          style={{\n            objectFit: \"fill\",\n            width: props.element.width,\n            height: props.element.height,\n            display: \"block\"\n          }}\n          alt={props.element.caption}\n          src={props.element?.url ? props.element.url : \"\"}\n        />\n      </div>\n    )\n  }\n};\n\nexport function ImageAddon(\n  props: AddonProps & {\n    onUploadRequest?: (files: globalThis.FileList | null) => Promise<string>;\n    onRemoved?: (url: string | null) => void;\n    onChange?: (images: ImageElement[]) => void;\n  }\n) {\n  const editor = useSlate();\n  const fileRef = useRef<HTMLInputElement>(null);\n\n  usePlugin({\n    isVoid: isVoid => element =>\n      isImageElement(element) && element.type === \"image\"\n        ? true\n        : isVoid(element),\n    insertData: (insertData, editor) => data => {\n      const { files } = data;\n      if (files && files.length > 0) {\n        for (const file of Array.from(files)) {\n          const reader = new FileReader();\n          const [mime] = file.type.split(\"/\");\n          if (mime === \"image\") {\n            reader.addEventListener(\"load\", () => {\n              const url = reader.result as string;\n              insertImage(editor, url);\n            });\n            reader.readAsDataURL(file);\n          }\n        }\n      } else {\n        insertData(data);\n      }\n    }\n  });\n\n  const onPreview = (dataUrl: FileReader[\"result\"]) => {\n    if (typeof dataUrl === \"string\") {\n      if (HistoryEditor.isHistoryEditor(editor)) {\n        HistoryEditor.withoutSaving(editor, () => {\n          Transforms.setNodes(editor, {\n            url: dataUrl\n          });\n        });\n      }\n    }\n  };\n\n  const handleFile = async (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!editor.selection) {\n      return;\n    }\n    const imageRef = Editor.rangeRef(editor, editor.selection);\n    const onUploadedSuccess = (url: string) => {\n      if (!imageRef.current) return;\n      const node = getNodeFromSelection(editor, imageRef.current);\n      if (node && isImageElement(node)) {\n        Transforms.setNodes(\n          editor,\n          {\n            url,\n            align: \"center\"\n          },\n          { at: imageRef.current! }\n        );\n        imageRef.unref();\n      }\n    };\n\n    const onUploadedFailed = () => {\n      if (!imageRef.current) return;\n      Transforms.setNodes(\n        editor,\n        {\n          // url: null,\n          error: \"failedupload\"\n        },\n        { at: imageRef.current }\n      );\n      imageRef.unref();\n    };\n\n    const files = e.target.files;\n    if (!files) {\n      return;\n    }\n    if (files.length > 0) {\n      const file = files[0];\n      const reader = new FileReader();\n      reader.addEventListener(\"load\", () => onPreview(reader.result));\n      reader.readAsDataURL(file);\n      if (props.onUploadRequest) {\n        try {\n          const url = await props.onUploadRequest(files);\n          onUploadedSuccess(url);\n        } catch (err) {\n          onUploadedFailed();\n        }\n      }\n    }\n  };\n\n  let imageUrls: ImageElement[] = [];\n  if (props.onChange) {\n    imageUrls = getAllImageNodes(editor)\n      .map(it => it)\n      .filter(isDefined)\n      .filter(isFilled);\n  }\n\n  useEffect(() => {\n    props.onChange && props.onChange(imageUrls);\n  }, [JSON.stringify(imageUrls), props.onChange]);\n\n  useRenderElement<ImageElement>(\n    {\n      typeMatch: \"image\",\n      renderElement: renderElementProps => (\n        <ImageBlock\n          onOpenFileRequest={() => fileRef.current && fileRef.current.click()}\n          onRemoved={props.onRemoved}\n          {...renderElementProps}\n        />\n      )\n    },\n    [props.onRemoved]\n  );\n\n  return (\n    <FileUpload\n      accept={\"image/*\"}\n      ref={fileRef}\n      onChange={handleFile}\n      multiple={false}\n    />\n  );\n}\n\nImageAddon.Presenter = Presenter;\n","import React, {\n  useEffect,\n  useRef,\n  useState,\n  useCallback,\n  ReactNode\n} from \"react\";\nimport { useSlate, useEditor } from \"slate-react\";\nimport { Element, Editor, Transforms, Range, Node } from \"slate\";\nimport { AddonProps } from \"../../addon\";\nimport isUrl from \"is-url\";\nimport { ToolBtnPopup } from \"../../ToolBtnPopup\";\nimport { useOnClickOutside } from \"../../utils\";\nimport { StyledToolBox } from \"../../StyledToolBox\";\nimport { InputWrapper, Input } from \"../../InputWrapper\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { usePlugin } from \"../../chief/hooks/use-plugin\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { ChiefElement } from \"../../chief\";\nimport { shortcutText } from \"../../shortcut\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\nimport { ElementHoverTip } from \"../../element-hover-tip\";\nimport { useSaveSelection } from \"../../chief/utils/saved-selection\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nexport const isLinkELement = (element: Element) => {\n  return element.type === \"link\" && typeof element.url === \"string\";\n};\n\nexport function LinkAddon(props: AddonProps) {\n  useLabels(props.labels);\n  usePlugin({\n    insertText: (insertText, editor) => text => {\n      if (text && isUrl(text)) {\n        wrapLink(editor, text);\n      } else {\n        insertText(text);\n      }\n    },\n    insertData: (insertData, editor) => data => {\n      const text = data.getData(\"text/plain\");\n      if (text && isUrl(text)) {\n        wrapLink(editor, text);\n      } else {\n        insertData(data);\n      }\n    },\n    isInline: isInline => element => {\n      // console.log(\"isInline, link\");\n      return isLinkELement(element) ? true : isInline(element);\n    }\n  });\n\n  useRenderElement<{ url: string } & ChiefElement>({\n    typeMatch: \"link\",\n    renderElement: props => (\n      <ElementHoverTip\n        delayed\n        placement=\"bottom\"\n        tip={\n          <span>\n            <a target=\"_blank\" href={props.element.url}>\n              {props.element.url}\n            </a>\n          </span>\n        }\n      >\n        {triggerRef => (\n          <a {...props.attributes} href={props.element.url}>\n            <span ref={triggerRef}>{props.children}</span>\n          </a>\n        )}\n      </ElementHoverTip>\n    )\n  });\n  return null;\n}\n\nexport function LinkControl(props: ControlProps) {\n  const editor = useEditor();\n  const isActive = isLinkActive(editor);\n  if (\n    !useIsControlEligable({\n      isText: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <ToolBtnPopup\n      shortcut={\"mod+k\"}\n      renderContent={setShow => (\n        <StyledToolBox>\n          <LinkPopup onClose={() => setShow(false)}></LinkPopup>\n        </StyledToolBox>\n      )}\n      renderToolBtn={(tprops, show) => (\n        <ToolbarBtn\n          tooltip={{\n            label: {\n              key: \"elements.link\",\n              defaultLabel: \"Add link\"\n            },\n            shortcut: shortcutText(\"mod+k\")\n          }}\n          {...tprops}\n          isActive={isActive || show}\n        >\n          {props.children}\n        </ToolbarBtn>\n      )}\n    />\n  );\n}\n\nconst Presenter: iPresenter<{ url: string } & ChiefElement> = {\n  element: {\n    typeMatch: \"link\",\n    renderElement: props => <a href={props.element.url}>{props.children}</a>\n  }\n};\n\nLinkAddon.Presenter = Presenter;\n\nexport const insertLink = (editor: Editor, url: string) => {\n  if (editor.selection) {\n    wrapLink(editor, url);\n  }\n};\n\nexport const isLinkActive = (editor: Editor) => {\n  const [link] = Editor.nodes(editor, { match: n => n.type === \"link\" });\n  return Boolean(link);\n};\n\nconst unwrapLink = (editor: Editor) => {\n  Transforms.unwrapNodes(editor, { match: n => n.type === \"link\" });\n};\n\nconst wrapLink = (editor: Editor, url: string) => {\n  if (isLinkActive(editor)) {\n    unwrapLink(editor);\n  }\n\n  const { selection } = editor;\n  const isCollapsed = selection && Range.isCollapsed(selection);\n  const link = {\n    type: \"link\",\n    url,\n    children: isCollapsed ? [{ text: url }] : []\n  };\n\n  if (isCollapsed) {\n    Transforms.insertNodes(editor, link);\n  } else {\n    Transforms.wrapNodes(editor, link, { split: true });\n    Transforms.collapse(editor, { edge: \"end\" });\n  }\n};\n\nfunction LinkPopup(props: { onClose: () => void }) {\n  const editor = useSlate();\n  const { selection } = editor;\n  const { saveSelection } = useSaveSelection();\n  useEffect(() => {\n    return saveSelection(selection);\n  }, []);\n  const linkWrapperRef = useRef<HTMLFormElement>(null);\n  useOnClickOutside(linkWrapperRef, () => {\n    props.onClose();\n  });\n  let linkNode: Node | null = null;\n  if (selection) {\n    const [_linkNode] = Editor.nodes(editor, {\n      at: selection,\n      match: n => n.type === \"link\"\n    });\n    linkNode = _linkNode && _linkNode[0];\n  }\n  const [url, setUrl] = useState(\"\");\n  useEffect(() => {\n    if (linkNode && typeof linkNode.url === \"string\") {\n      setUrl(linkNode.url);\n    }\n  }, [linkNode]);\n  const handleInsertLink = useCallback(() => {\n    if (url.length > 0) {\n      insertLink(editor, url);\n      props.onClose();\n    } else if (\n      linkNode &&\n      typeof linkNode.url === \"string\" &&\n      linkNode.url.length > 0\n    ) {\n      unwrapLink(editor);\n      props.onClose();\n    }\n  }, [url]);\n\n  const handleUnlink = useCallback(() => {\n    unwrapLink(editor);\n    props.onClose();\n  }, [url]);\n\n  const [getLabel] = useLabels();\n\n  return (\n    <form ref={linkWrapperRef} onSubmit={handleInsertLink}>\n      <div\n        style={{\n          padding: 9,\n          display: \"flex\",\n          minWidth: 400,\n          flexDirection: \"row\"\n        }}\n      >\n        <InputWrapper>\n          <Input\n            value={url}\n            onChange={(e: React.FormEvent<HTMLInputElement>) =>\n              setUrl(e.currentTarget.value)\n            }\n            placeholder={getLabel({\n              key: \"elements.link.placeholder\",\n              defaultLabel: \"Paste or type your link here\"\n            })}\n            autoFocus\n          />\n        </InputWrapper>\n        <ToolbarBtn\n          rounded\n          disabled={url.length === 0}\n          onMouseDown={handleInsertLink}\n        >\n          {getLabel({\n            key: \"elements.link.btn.link\",\n            defaultLabel: \"Link\"\n          })}\n        </ToolbarBtn>\n        <ToolbarBtn\n          rounded\n          disabled={\n            !isLinkActive(editor)\n            // || (linkNode &&\n            //   typeof linkNode.url === \"string\" &&\n            //   linkNode.url.length > 0)\n          }\n          onMouseDown={handleUnlink}\n        >\n          {getLabel({\n            key: \"elements.link.btn.unlink\",\n            defaultLabel: \"Unlink\"\n          })}\n        </ToolbarBtn>\n      </div>\n    </form>\n  );\n}\n","import { Editor, Transforms, Node } from \"slate\";\n\nexport const toggleElement = (editor: Editor, type: string) => {\n  const isActive = isElementActive(editor, type);\n  const { selection } = editor;\n  if (!selection) {\n    return;\n  }\n  Transforms.setNodes(editor, {\n    type: isActive ? \"paragraph\" : type,\n    autoFocus: true,\n    at: selection.focus\n  });\n};\n\nexport const isElementActive = (editor: Editor, type: string) => {\n  const { selection } = editor;\n  if (!selection) {\n    return false;\n  }\n  const [match] = Editor.nodes(editor, {\n    at: selection,\n    match: n => n.type === type\n  });\n  return !!match;\n};\n\nexport const isElementEmpty = (editor: Editor) => {\n  const { selection } = editor;\n\n  if (selection) {\n    const [node] = Editor.parent(editor, selection.focus);\n    return Node.string(node).length === 0;\n  }\n  return false;\n};\n","import { ReactEditor } from \"slate-react\";\nimport { isElementActive } from \"../../element-utils\";\nimport { Transforms, Editor } from \"slate\";\nimport { TYPE_LIST_ITEM } from \".\";\n\nexport const toggleList = (editor: ReactEditor, type: string) => {\n  const isActive = isElementActive(editor, type);\n  Transforms.unwrapNodes(editor, {\n    match: n => n.type === type,\n    split: true\n  });\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.setNodes(editor, {\n      type: isActive ? \"paragraph\" : TYPE_LIST_ITEM\n    });\n\n    if (!isActive) {\n      const list = {\n        type,\n        children: []\n      };\n      Transforms.wrapNodes(editor, list);\n    }\n  });\n};\n","import React from \"react\";\nimport { RenderElementProps } from \"slate-react\";\n\nexport const renderElement = (\n  props: RenderElementProps,\n  elementType: string,\n  reactType: Parameters<typeof React.createElement>[\"0\"],\n  addionalProps?: any\n) => {\n  const { children, attributes, element } = props;\n  if (element.type === elementType) {\n    return React.createElement(\n      reactType,\n      { ...attributes, ...addionalProps },\n      children\n    );\n  }\n  return undefined;\n};\n","import { ReactEditor, useSlate } from \"slate-react\";\nimport { Point, Editor, Range, Node } from \"slate\";\nimport { ChiefElement, isChiefElement } from \"./chief\";\n\ninterface ChiefState {\n  editor: ReactEditor;\n  element?: ChiefElement | Editor | undefined;\n  elementType?: string;\n  point?: Point;\n  isElementEmpty: boolean;\n  selection?: Range | null;\n  isSelectionCollapsed: boolean;\n  isSelectionExpanded: boolean;\n}\n\nexport function getState(editor: ReactEditor): ChiefState {\n  const { selection } = editor;\n  const point = selection ? selection.focus : undefined;\n  const [element] = point ? Editor.parent(editor, point) : [];\n\n  let isSelectionExpanded = false;\n  let isSelectionCollapsed = true;\n  if (selection) {\n    isSelectionExpanded = Range.isExpanded(selection);\n    isSelectionCollapsed = Range.isCollapsed(selection);\n  }\n\n  let isElementEmpty = true;\n\n  if (element) {\n    isElementEmpty = Node.string(element).length == 0;\n  }\n  let elementType: string | undefined = undefined;\n\n  if (element && isChiefElement(element)) {\n    elementType = element.type;\n  }\n\n  return {\n    editor,\n    // TODO:: THIS\n    // @ts-ignore\n    element,\n    elementType,\n    point,\n    selection,\n    isElementEmpty,\n    isSelectionExpanded,\n    isSelectionCollapsed\n  };\n}\n","import { toggleList } from \"./transforms\";\nimport { ChiefElement, InjectedRenderElement } from \"../../chief/chief\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { usePlugin } from \"../../chief/hooks/use-plugin\";\nimport { renderElement } from \"../../element-renderer\";\nimport { Editor, Transforms, Element, Range } from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nimport { isElementEmpty } from \"../../element-utils\";\nimport { getState } from \"../../chief/chief-state\";\nimport { getAncestor, getActiveNode } from \"../../utils\";\nimport { AddonProps } from \"../../addon\";\nimport styled from \"styled-components\";\nimport { iPresenter } from \"../../chief\";\n\nexport const TYPE_LIST_ITEM = \"list-item\";\nexport const TYPE_UNORDERED_LIST = \"unordered-list\";\nexport const TYPE_ORDERED_LIST = \"ordered-list\";\nexport const LIST_TYPES = [\n  TYPE_LIST_ITEM,\n  TYPE_UNORDERED_LIST,\n  TYPE_ORDERED_LIST\n];\n\ntype ListElement = {} & ChiefElement;\n\nconst Ul = styled.ul`\n  margin: 0;\n  padding-inline-start: 25px;\n  ul ul ul ul,\n  ul {\n    list-style: square outside none;\n  }\n\n  ul ul ul ul ul,\n  ul ul {\n    list-style: circle outside none;\n  }\n\n  ul ul ul ul ul ul,\n  ul ul ul {\n    list-style: disc outside none;\n  }\n`;\nconst Ol = styled.ol`\n  margin: 0;\n  padding-inline-start: 25px;\n  ol ol ol ol,\n  ol {\n    list-style: decimal outside none;\n  }\n  ol ol ol ol ol,\n  ol ol {\n    list-style: lower-latin outside none;\n  }\n  ol ol ol ol ol ol,\n  ol ol ol {\n    list-style: lower-roman outside none;\n  }\n`;\n\nconst Li = styled.li``;\n\nconst _renderElement: InjectedRenderElement = {\n  typeMatch: LIST_TYPES,\n  renderElement: props => {\n    switch (props.element.type) {\n      case TYPE_UNORDERED_LIST:\n        return renderElement(props, props.element.type, Ul);\n      case TYPE_ORDERED_LIST:\n        return renderElement(props, props.element.type, Ol);\n      default:\n        return renderElement(props, TYPE_LIST_ITEM, Li);\n    }\n  }\n};\n\nconst Presenter: iPresenter = {\n  element: _renderElement\n};\n\nexport function ListsAddon(props: AddonProps) {\n  usePlugin({\n    normalizeNode: (normalizeNode, editor) => ([node, path]) => {\n      if (node.type === TYPE_LIST_ITEM) {\n        const [parent] = Editor.parent(editor, path);\n        if (\n          parent &&\n          ![TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST].includes(\n            parent.type as string\n          )\n        ) {\n          Transforms.setNodes(editor, { type: \"paragraph\" }, { at: path });\n        }\n      }\n      return normalizeNode([node, path]);\n    }\n  });\n\n  useRenderElement<ListElement>(_renderElement);\n\n  useOnKeyDown({\n    pattern: \"enter\",\n    handler: (e, editor) => {\n      const { elementType, element } = getState(editor);\n      if (elementType !== TYPE_LIST_ITEM) {\n        return false;\n      }\n      let ancestor = getAncestor(editor, element as Element, 1);\n\n      if (\n        !ancestor ||\n        ![TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST].includes(\n          ancestor!.type as string\n        )\n      ) {\n        return false;\n      }\n      e.preventDefault();\n      if (!isElementEmpty(editor)) {\n        Editor.withoutNormalizing(editor, () => {\n          Transforms.insertNodes(editor, {\n            type: TYPE_LIST_ITEM,\n            children: [{ text: \"\" }]\n          });\n        });\n      } else {\n        const active = getActiveNode(editor);\n        if (!active) {\n          return false;\n        }\n        const list = getAncestor(editor, active, 1) as Element;\n        const listParent = getAncestor(editor, active, 2);\n\n        if (listParent && listParent.children[0].type === TYPE_LIST_ITEM) {\n          //2. If nested then unwrap and move left\n          Transforms.unwrapNodes(editor, {\n            match: n => n.type === list.type,\n            split: true\n          });\n        } else {\n          //3. At top level so cannot unwrap, insert new paragraph and break from list\n          toggleList(editor, list.type as string);\n        }\n      }\n\n      return true;\n    }\n  });\n  useOnKeyDown({\n    pattern: \"tab\",\n    handler: (e, editor) => {\n      const { elementType, element } = getState(editor);\n      if (!element || elementType !== TYPE_LIST_ITEM) {\n        return false;\n      }\n\n      let ancestor = getAncestor(editor, element, 1);\n      if (\n        !ancestor ||\n        ![TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST].includes(\n          ancestor!.type as string\n        )\n      ) {\n        return false;\n      }\n\n      if (ancestor.children.length > 1) {\n        e.preventDefault();\n        const index = ancestor?.children.indexOf(element) - 1;\n        if (ancestor.children[index].type !== TYPE_LIST_ITEM) {\n          // 3a. tab = move right. If the node above is a list then append to it.\n          const otherList = ancestor.children[index] as Element;\n          const destination = ReactEditor.findPath(\n            editor,\n            otherList.children[otherList.children.length - 1]\n          );\n          destination[destination.length - 1]++;\n          Transforms.moveNodes(editor, {\n            to: destination\n          });\n        } else {\n          // 3b. otherwise, wrap the item in a new list and nest in parent\n          Transforms.wrapNodes(editor, { type: ancestor.type, children: [] });\n        }\n        return true;\n      }\n      return false;\n    }\n  });\n  useOnKeyDown({\n    pattern: \"shift+tab\",\n    handler: (e, editor) => {\n      const { elementType, element } = getState(editor);\n      if (!element || elementType !== TYPE_LIST_ITEM) {\n        return false;\n      }\n\n      let ancestor = getAncestor(editor, element, 1);\n      if (\n        !ancestor ||\n        ![TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST].includes(\n          ancestor!.type as string\n        )\n      ) {\n        return false;\n      }\n\n      if (e.shiftKey) {\n        let ancestor = getAncestor(editor, element, 2);\n        // 1. tab+shift = move left to grandparent list if nested\n        if (ancestor?.children.find(child => child.type === TYPE_LIST_ITEM)) {\n          Transforms.liftNodes(editor);\n        } else {\n          const options = {\n            at: ReactEditor.findPath(editor, element)\n          };\n          // 2. tab+shift = unwrap and move to below parent if no grandparent list\n          if (element?.children.length == 1) {\n            Transforms.setNodes(editor, { type: \"paragraph\" }, options);\n          } else {\n            Transforms.unwrapNodes(editor, options);\n          }\n        }\n        e.preventDefault();\n        return true;\n      }\n      return false;\n    }\n  });\n  return null;\n}\n\nListsAddon.Presenter = Presenter;\n","import React from \"react\";\nimport { toggleList } from \"./transforms\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { isNodeActive } from \"../../utils\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST } from \"./index\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nexport function ListControl(\n  props: {\n    type: typeof TYPE_ORDERED_LIST | typeof TYPE_UNORDERED_LIST;\n  } & ControlProps\n) {\n  const editor = useSlate();\n  const { type, children } = props;\n  if (\n    !useIsControlEligable({\n      isText: true,\n      isEmpty: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <ToolbarBtn\n      tooltip={{\n        label: {\n          key: `elements.${type}`,\n          defaultLabel: type\n        }\n      }}\n      isActive={isNodeActive(editor, type)}\n      onClick={() => {\n        toggleList(editor, type);\n        ReactEditor.focus(editor);\n      }}\n    >\n      {children || type}\n    </ToolbarBtn>\n  );\n}\n","import { AddonProps } from \"../../addon\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\n\nexport function BlockTabAddon(props: AddonProps) {\n  useOnKeyDown({\n    pattern: \"tab\",\n    priority: \"low\",\n    handler: e => {\n      e.preventDefault();\n      return true;\n    }\n  });\n  return null;\n}\n","import { useOnClickOutside } from \"../../utils\";\nimport React, { useState, useCallback, useEffect, useRef } from \"react\";\nimport { useSlate, ReactEditor } from \"slate-react\";\nimport { Node, Editor, Path, Transforms } from \"slate\";\nimport { Manager, Reference, Popper } from \"react-popper\";\nimport styled from \"styled-components\";\nimport { ButtonBase } from \"../../ui/button-base\";\n\nexport const BlockInsertBtn = styled(ButtonBase)`\n  user-select: none;\n  border: none;\n  background: transparent;\n  display: block;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #ccc;\n  border-radius: ${25 / 2}px;\n  &:before {\n    content: \"+\";\n    font-family: Arial, Helvetica, sans-serif;\n    font-weight: normal;\n    font-size: 28px;\n    color: #ccc;\n    position: absolute;\n    top: -3px;\n    left: 4px;\n    padding: 0;\n    margin: 0;\n  }\n  &:hover {\n    &:before {\n      color: #ddd;\n    }\n  }\n  &:active {\n    &:before {\n      color: #eee;\n    }\n  }\n`;\n\nfunction useHoveredNode(editor: ReactEditor) {\n  const [node, setNode] = useState<{ node: Node; path: Path } | null>(null);\n  useEffect(() => {\n    try {\n      const [rootNode] = Editor.node(editor, {\n        anchor: Editor.start(editor, []),\n        focus: Editor.end(editor, [])\n      });\n      if (rootNode && Node.isNode(rootNode)) {\n        const firstDOMPoint = ReactEditor.toDOMNode(editor, rootNode);\n        firstDOMPoint.addEventListener(\"mousemove\", e => {\n          if (ReactEditor.hasDOMNode(editor, e.target as globalThis.Node)) {\n            const node = ReactEditor.toSlateNode(\n              editor,\n              e.target as globalThis.Node\n            );\n            const path = ReactEditor.findPath(editor, node);\n            setNode({ node, path });\n          } else {\n            setNode(null);\n          }\n        });\n      }\n    } catch (err) {\n      setNode(null);\n    }\n  }, [editor]);\n  return node;\n}\n\nexport function BlockInsert(props: { children?: React.ReactNode }) {\n  const editor = useSlate();\n  const [coords, setCoords] = useState([-1000, -1000]);\n  const [showMenu, setShowMenu] = useState(false);\n  const toolboxRef = useRef<HTMLDivElement>(null);\n  useOnClickOutside(toolboxRef, () => {\n    setShowMenu(false);\n  });\n\n  const hoveredNode = useHoveredNode(editor);\n\n  const handleBlockInsert = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n      event.preventDefault();\n      event.stopPropagation();\n      if (!showMenu && hoveredNode) {\n        Transforms.select(editor, hoveredNode.path);\n      }\n      setShowMenu(!showMenu);\n      ReactEditor.focus(editor);\n    },\n    [showMenu, hoveredNode]\n  );\n\n  useEffect(() => {\n    if (hoveredNode?.node && !showMenu) {\n      try {\n        const [rootNode] = Editor.node(editor, {\n          anchor: Editor.start(editor, []),\n          focus: Editor.end(editor, [])\n        });\n        if (rootNode && Node.isNode(rootNode)) {\n          const firstDOMPoint = ReactEditor.toDOMNode(editor, rootNode);\n          const activeDOMNode = ReactEditor.toDOMNode(editor, hoveredNode.node);\n          const rect = activeDOMNode.getBoundingClientRect();\n          const top = rect.top + window.pageYOffset + rect.height / 2 - 25 / 2;\n          const left =\n            firstDOMPoint.getBoundingClientRect().left +\n            window.pageXOffset -\n            30;\n          setCoords([top, left]);\n        }\n      } catch (err) {\n        /*ignore*/\n      }\n    }\n  }, [hoveredNode]);\n\n  if (\n    !hoveredNode ||\n    hoveredNode.path.length === 0 ||\n    Node.string(hoveredNode.node).length !== 0 ||\n    Editor.isVoid(editor, hoveredNode.node)\n  ) {\n    if (!showMenu) {\n      return null;\n    }\n  }\n  return (\n    <Manager>\n      <Reference>\n        {({ ref }) => (\n          <div\n            ref={ref}\n            style={{ position: \"absolute\", top: coords[0], left: coords[1] }}\n          >\n            <BlockInsertBtn onClick={handleBlockInsert} />\n          </div>\n        )}\n      </Reference>\n      {showMenu && (\n        <Popper\n          placement=\"bottom-end\"\n          modifiers={[\n            {\n              name: \"offset\",\n              options: {\n                offset: [25, 10]\n              }\n            }\n          ]}\n        >\n          {({ ref, style, placement, arrowProps }) => (\n            <div\n              ref={ref}\n              style={{ ...style, zIndex: 20 }}\n              data-placement={placement}\n              onMouseDown={e => {\n                if (!e.isDefaultPrevented()) {\n                  e.preventDefault();\n                  setShowMenu(false);\n                  ReactEditor.focus(editor);\n                  editor.selection &&\n                    Transforms.select(editor, editor.selection.focus);\n                }\n              }}\n            >\n              <div ref={toolboxRef}>{props.children}</div>\n              <div ref={arrowProps.ref} style={arrowProps.style} />\n            </div>\n          )}\n        </Popper>\n      )}\n    </Manager>\n  );\n}\n","import React from \"react\";\nimport { Range, Node } from \"slate\";\nimport { useDecoration } from \"../hooks/use-decoration\";\nimport { useRenderLeaf } from \"..\";\n\nexport function useHighlightSelection(\n  selection: Range | null | undefined,\n  style: React.CSSProperties) {\n  useRenderLeaf(\n    {\n      renderLeaf: props => {\n        return (\n          <span\n            style={props.leaf.highlightSelection ? style : undefined}\n            {...props.attributes}\n          >\n            {props.children}\n          </span>\n        );\n      }\n    },\n    [selection]\n  );\n\n  useDecoration(\n    {\n      decorator: ([node]) => {\n        const ranges: Range[] = [];\n        if (selection && Node.has(node, selection.anchor.path)) {\n          ranges.push({ ...selection, highlightSelection: true });\n        }\n        return ranges;\n      }\n    },\n    [selection]\n  );\n}\n","import { useEffect } from \"react\";\nimport { useChief } from \"./use-chief\";\nimport { InjectedDecorator } from \"../chief\";\n\nexport function useDecoration(decoration: InjectedDecorator, deps?: any[]) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectDecoration(decoration);\n    return () => chief.removeDecoration(decoration);\n  }, deps);\n}\n","import React, { useEffect, useState, useRef, useContext } from \"react\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { Editor, Range, Transforms } from \"slate\";\nimport { Popper } from \"react-popper\";\nimport { VirtualElement } from \"@popperjs/core\";\nimport { useOnClickOutside, getNodeFromSelection } from \"../../utils\";\nimport { useChief } from \"../../chief/hooks/use-chief\";\nimport { useHighlightSelection } from \"../../chief/utils/use-highlight-selection\";\nimport { useSaveSelection } from \"../../chief/utils/saved-selection\";\n\nexport const deselect = Transforms.deselect;\nTransforms.deselect = (..._args) => {\n  // We disable the default deselect.\n};\n\ntype HoverToolContext = ReturnType<typeof useProvideContext>[\"ctx\"];\n\nconst hoverToolContext = React.createContext<HoverToolContext | undefined>(\n  undefined\n);\n\nfunction useProvideContext() {\n  const editor = useSlate();\n  const { selection } = editor;\n\n  const isEditorFocused = ReactEditor.isFocused(editor);\n  const isCollapsed = selection && Range.isCollapsed(selection);\n  const isEmpty = selection && Editor.string(editor, selection) === \"\";\n  const currentNode = getNodeFromSelection(editor, selection);\n  const isVoid = Editor.isVoid(editor, currentNode);\n  const isReadOnly = useChief().readOnly;\n  const { savedSelection } = useSaveSelection();\n  useHighlightSelection(savedSelection?.current, {\n    backgroundColor: \"#969696\"\n  });\n\n  // console.log({\n  //   isEditorFocused,\n  //   selection,\n  //   isCollapsed,\n  //   isEmpty,\n  //   isVoid,\n  //   ...ctx\n  // });\n\n  const [enabled, setEnabled] = useState(false);\n\n  useEffect(() => {\n    if (isReadOnly) {\n      setEnabled(false);\n    } else if (ctx.enabled) {\n      if (!savedSelection?.current && isCollapsed && !isVoid) {\n        setEnabled(false);\n      }\n    } else {\n      if (isEditorFocused) {\n        if (isCollapsed && isVoid) {\n          setEnabled(true);\n        } else if (!isCollapsed && !isEmpty) {\n          setEnabled(true);\n        }\n      }\n    }\n  }, [isEditorFocused, isCollapsed, isEmpty, isVoid]);\n\n  const ctx = {\n    enabled\n  };\n\n  return { ctx, setEnabled };\n}\n\nexport function useHoverTool() {\n  const ctx = useContext(hoverToolContext);\n  if (ctx === undefined) {\n    throw new Error(\"useHoverTool must be within a <HoverToolProvider/>\");\n  }\n  return ctx;\n}\n\nexport function HoverTools(props: { children?: React.ReactNode }) {\n  const { ctx, setEnabled } = useProvideContext();\n  return (\n    <hoverToolContext.Provider value={ctx}>\n      <HoveringTool\n        onChangeEnabled={enabled => setEnabled(enabled)}\n        enabled={ctx.enabled}\n      >\n        {props.children}\n      </HoveringTool>\n    </hoverToolContext.Provider>\n  );\n}\n\nexport const HoveringTool = (\n  props: {\n    children?: React.ReactNode;\n    enabled: boolean;\n    onChangeEnabled: (enabled: boolean) => void;\n  } & React.HTMLProps<HTMLDivElement>\n) => {\n  const { children, enabled, onChangeEnabled, ...otherProps } = props;\n  const editor = useSlate();\n  const { selection } = editor;\n  const [deltaOffset, setDeltaOffset] = useState(-1);\n  const currentNode = getNodeFromSelection(editor, selection);\n\n  useEffect(() => {\n    const deltaoffset = selection\n      ? selection.focus.offset - selection.anchor.offset\n      : -1;\n    setDeltaOffset(deltaoffset);\n  }, [selection]);\n\n  const toolRef = useRef(null);\n  const [_v, _setV] = useState<VirtualElement>({\n    getBoundingClientRect: () => ({\n      top: -1000,\n      left: -1000,\n      bottom: 0,\n      right: 0,\n      width: 1,\n      height: 1\n    })\n  });\n\n  useOnClickOutside(toolRef, e => {\n    if (currentNode) {\n      const domNode = ReactEditor.toDOMNode(editor, currentNode);\n      if (e.target && domNode.contains(e.target as globalThis.Node)) {\n        return;\n      }\n    }\n    onChangeEnabled(false);\n  });\n\n  useEffect(() => {\n    if (enabled) {\n      const isVoid = Editor.isVoid(editor, currentNode);\n      if (isVoid && currentNode) {\n        try {\n          const domNode = ReactEditor.toDOMNode(editor, currentNode);\n          _setV({\n            getBoundingClientRect: () => domNode.getBoundingClientRect()\n          });\n        } catch (err) {\n          console.log(err);\n        }\n      } else {\n        try {\n          const domSelection = window.getSelection();\n          if (domSelection && domSelection.rangeCount > 0) {\n            const domRange = domSelection.getRangeAt(0);\n            if (domRange && deltaOffset !== -1) {\n              _setV({\n                getBoundingClientRect: () => domRange.getBoundingClientRect()\n              });\n            }\n          }\n        } catch (err) {\n          console.log(err);\n        }\n      }\n    }\n  }, [enabled, deltaOffset, selection, currentNode]);\n\n  if (!enabled || !children) {\n    return null;\n  }\n\n  return (\n    <Popper\n      modifiers={[\n        {\n          name: \"offset\",\n          options: {\n            offset: [0, 10]\n          }\n        }\n      ]}\n      placement=\"top-end\"\n      referenceElement={_v}\n    >\n      {({ ref, style, placement, arrowProps }) => (\n        <div\n          ref={ref}\n          style={{ ...style, zIndex: 10 }}\n          data-placement={placement}\n        >\n          <div ref={toolRef} {...otherProps}>\n            {children}\n          </div>\n          <div ref={arrowProps.ref} style={arrowProps.style} />\n        </div>\n      )}\n    </Popper>\n  );\n};\n","import React, { ReactNode, useCallback, useEffect, useRef } from \"react\";\nimport { Text, Transforms } from \"slate\";\nimport { useSlate } from \"slate-react\";\nimport { AddonProps } from \"../../addon\";\nimport { ChiefElement, iPresenter, useRenderLeaf } from \"../../chief\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { StyledToolBox } from \"../../StyledToolBox\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { ToolBtnPopup } from \"../../ToolBtnPopup\";\nimport { useOnClickOutside } from \"../../utils\";\nimport { useSaveSelection } from \"../../chief/utils/saved-selection\";\nimport { ControlProps, useIsControlEligable } from \"../../chief/controls\";\n\nexport function TextColorAddon() {\n  useRenderLeaf({\n    renderLeaf: props => {\n      if (typeof props.leaf[\"color\"] === \"string\")\n        return (\n          <span\n            style={{ color: props.leaf[\"color\"] as string }}\n            {...props.attributes}\n          >\n            {props.children}\n          </span>\n        );\n      return undefined;\n    }\n  });\n  return null;\n}\n\nexport function TextColorControl(props: { colors?: string[] } & ControlProps) {\n  if (\n    !useIsControlEligable({\n      isText: true\n    })\n  ) {\n    return null;\n  }\n  return (\n    <ToolBtnPopup\n      renderContent={setShow => (\n        <StyledToolBox>\n          <ColorSelector\n            colors={\n              props.colors || [\n                \"rgb(142, 209, 252)\",\n                \"rgb(132, 109, 52)\",\n                \"rgb(42, 09, 232)\",\n                \"rgb(54, 209, 12)\"\n              ]\n            }\n            onClose={() => setShow(false)}\n          />\n        </StyledToolBox>\n      )}\n      renderToolBtn={(tprops, show) => (\n        <ToolbarBtn\n          tooltip={{\n            label: {\n              key: \"marks.textcolor\",\n              defaultLabel: \"Textcolor\"\n            }\n          }}\n          {...tprops}\n          isActive={show}\n        >\n          {props.children}\n        </ToolbarBtn>\n      )}\n    />\n  );\n}\n\nconst Presenter: iPresenter<{ url: string } & ChiefElement> = {\n  leaf: {\n    renderLeaf: props =>\n      renderLeaf(props, \"color\", \"span\", {\n        style: { color: props.leaf[\"color\"] }\n      })\n  }\n};\nTextColorAddon.Presenter = Presenter;\n\nfunction ColorSelector(props: { onClose: () => void; colors: string[] }) {\n  const editor = useSlate();\n  const { onClose, colors } = props;\n  const { selection } = editor;\n  const { saveSelection } = useSaveSelection();\n  useEffect(() => {\n    return saveSelection(selection);\n  }, []);\n  const wrapperRef = useRef<HTMLDivElement>(null);\n  useOnClickOutside(wrapperRef, () => {\n    onClose();\n  });\n  const handleChangeTextColor = useCallback(\n    (color?: string) => {\n      Transforms.setNodes(\n        editor,\n        { color },\n        { match: n => Text.isText(n), split: true }\n      );\n      onClose();\n    },\n    [colors]\n  );\n\n  return (\n    <div\n      ref={wrapperRef}\n      style={{\n        padding: 9,\n        display: \"flex\",\n        flexDirection: \"row\"\n      }}\n    >\n      <div style={{ display: \"flex\" }}>\n        <div\n          onClick={() => handleChangeTextColor(undefined)}\n          style={{\n            width: 18,\n            height: 18,\n            margin: 2,\n            backgroundColor: \"none\",\n            cursor: \"pointer\"\n          }}\n        />\n        {colors.map((color, i) => {\n          return (\n            <div\n              key={i}\n              onClick={() => handleChangeTextColor(color)}\n              style={{\n                width: 18,\n                height: 18,\n                margin: 2,\n                backgroundColor: color,\n                cursor: \"pointer\"\n              }}\n            />\n          );\n        })}\n      </div>\n      {/* <div style={{ display: \"flex\" }}>\n        {bgColors.map(color => {\n          return (\n            <div\n              onClick={handleChangeBgColor}\n              style={{\n                width: 18,\n                height: 18,\n                margin: 2,\n                backgroundColor: color,\n                cursor: \"pointer\"\n              }}\n            />\n          );\n        })}\n      </div> */}\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\nimport { Editor as SlateEditor } from \"slate\";\nimport {\n  Editor,\n  Chief,\n  // Addons\n  HeadingsAddon,\n  BoldAddon,\n  ItalicAddon,\n  UnderlineAddon,\n  StrikethroughAddon,\n  ImageAddon,\n  ResetToParagraphAddon,\n  PreventNewlineAddon,\n  ListsAddon,\n  BlockTabAddon,\n  ParagraphAddon,\n  LabelsAddon,\n  // Block toolbar addon\n  BlockInsert,\n  // Custom addon creation\n  AddonProps,\n  useRenderElement,\n  InputWrapper,\n  usePlugin,\n  // Presentation\n  BoldControl,\n  HeadingControl,\n  ItalicControl,\n  StrikethroughControl,\n  UnderlineControl,\n  HoverTools,\n  ImageControl,\n  ListControl,\n  TextColorAddon,\n  TextColorControl,\n  LinkAddon,\n  LinkControl,\n  ParagraphControl,\n  RenderControlProps,\n  StyledToolBox,\n  ToolsWrapper,\n  useOnKeyDown\n} from \"react-chief-editor\";\nimport { Node, Element } from \"slate\";\nimport styled, { css } from \"styled-components\";\nimport MdiIcon from \"@mdi/react\";\nimport {\n  mdiFormatParagraph,\n  mdiFormatHeader1,\n  mdiFormatHeader2,\n  mdiFormatHeader3,\n  mdiFormatHeader4,\n  mdiFormatHeader5,\n  mdiFormatHeader6,\n  mdiFormatListNumbered,\n  mdiFormatListBulleted,\n  mdiFormatBold,\n  mdiFormatItalic,\n  mdiFormatStrikethrough,\n  mdiFormatUnderline,\n  mdiImage,\n  mdiLink,\n  mdiFormatColorText\n} from \"@mdi/js\";\nimport lorem from \"./lorem.json\";\n\nfunction Icon(\n  props: React.ComponentProps<typeof MdiIcon> & Partial<RenderControlProps>\n) {\n  const { isActive, theme, ...otherProps } = props;\n  return (\n    <MdiIcon\n      color={isActive ? theme?.colors?.primary : \"#2b2b2b\"}\n      size={0.7}\n      {...otherProps}\n    ></MdiIcon>\n  );\n}\n\nconst editorLabels = {\n  \"marks.bold\": \"Fed\",\n  \"marks.italic\": \"Kursiv\",\n  \"marks.strikethrough\": \"Gennemstreg\",\n  \"marks.underline\": \"Understreg\",\n  \"marks.textcolor\": \"Tekstfarve\",\n  \"elements.image\": \"Billede\",\n  \"elements.link\": \"Link\",\n  \"elements.ordered-list\": \"Nummereret list\",\n  \"elements.unordered-list\": \"Punkt list\",\n  \"elements.link.placeholder\": \"Indst eller skriv link\",\n  \"elements.link.btn.link\": \"Tilfj\",\n  \"elements.link.btn.unlink\": \"Fjern\",\n  \"elements.paragraph.hint\": \"Klik for at redigere\",\n  \"elements.paragraph.placeholder\": \"Tekst\",\n  \"elements.heading.h1.placeholder\": \"Overskrift 1\",\n  \"elements.heading.h2.placeholder\": \"Overskrift 2\",\n  \"elements.heading.h3.placeholder\": \"Overskrift 3\",\n  \"elements.heading.h4.placeholder\": \"Overskrift 4\",\n  \"elements.heading.h5.placeholder\": \"Overskrift 5\",\n  \"elements.heading.h6.placeholder\": \"Overskrift 6\"\n};\n\nfunction ColumnsAddon(props: AddonProps) {\n  usePlugin({});\n\n  useOnKeyDown({\n    pattern: \"enter\",\n    handler: (e, editor) => {\n      const { selection } = editor;\n      if (selection) {\n        const [node] = SlateEditor.nodes(editor, {\n          at: selection,\n          match: n => n.type === \"columns\"\n        });\n        if (node) {\n          e.preventDefault();\n          editor.insertText(\"\\n\");\n        }\n      }\n    }\n  });\n\n  useRenderElement({\n    typeMatch: \"columns\",\n    renderElement: (props, editor) => {\n      return (\n        <div\n          {...props.attributes}\n          style={{ display: \"flex\", flexDirection: \"row\" }}\n        >\n          {props.children}\n        </div>\n      );\n    }\n  });\n\n  useRenderElement({\n    typeMatch: \"column\",\n    renderElement: (props, editor) => {\n      return (\n        <div\n          style={{ flex: 1, border: \"1px dashed #ccc\" }}\n          {...props.attributes}\n        >\n          {React.Children.map(props.children, it => it)}\n        </div>\n      );\n    }\n  });\n\n  return null;\n}\n\nconst ContentStyle = styled.div`\n  font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n  color: #4b4a4a;\n  font-size: 18px;\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    color: #202020;\n  }\n  a {\n    color: rgb(234 66 205);\n  }\n`;\n\nfunction App() {\n  const [value, setValue] = useState<Node[]>(lorem);\n\n  console.log(JSON.stringify(value));\n\n  return (\n    <div style={{ flex: 1 }}>\n      <ContentStyle>\n        <Chief\n          value={value}\n          onChange={value => setValue(value)}\n          theme={{\n            overrides: {\n              // StyledToolbarBtn: css`\n              //   background-color: transparent;\n              //   color: white;\n              //   padding: 10px;\n              //   &:hover {\n              //     background-color: ${props =>\n              //       // @ts-ignore\n              //       props.disabled ? undefined : \"#2d2d2d\"};\n              //   }\n              // `,\n              // StyledToolBox: css`\n              //   border-radius: 20px;\n              //   background-color: black;\n              // `,\n              // ui: css`\n              //   /* font-family: monospace; */\n              // `\n            }\n          }}\n        >\n          <ColumnsAddon />\n          <LabelsAddon labels={editorLabels} />\n          <ParagraphAddon />\n          <BoldAddon />\n          <ItalicAddon />\n          <UnderlineAddon />\n          <StrikethroughAddon />\n          <HeadingsAddon />\n          <ImageAddon />\n          <ResetToParagraphAddon />\n          <PreventNewlineAddon />\n          <PreventNewlineAddon />\n          <LinkAddon />\n          <ListsAddon />\n          <BlockTabAddon />\n          <TextColorAddon />\n          <div\n            style={{\n              marginLeft: 40\n            }}\n          >\n            <BlockInsert>\n              <StyledToolBox>\n                <ToolsWrapper>\n                  <ParagraphControl>\n                    {props => <Icon path={mdiFormatParagraph} {...props} />}\n                  </ParagraphControl>\n                  <HeadingControl heading=\"h1\">\n                    {props => <Icon path={mdiFormatHeader1} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h2\">\n                    {props => <Icon path={mdiFormatHeader2} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h3\">\n                    {props => <Icon path={mdiFormatHeader3} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h4\">\n                    {props => <Icon path={mdiFormatHeader4} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h5\">\n                    {props => <Icon path={mdiFormatHeader5} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h6\">\n                    {props => <Icon path={mdiFormatHeader6} {...props} />}\n                  </HeadingControl>\n                  <ListControl type=\"ordered-list\">\n                    {props => <Icon path={mdiFormatListNumbered} {...props} />}\n                  </ListControl>\n                  <ListControl type=\"unordered-list\">\n                    {props => <Icon path={mdiFormatListBulleted} {...props} />}\n                  </ListControl>\n                  <ImageControl>\n                    {props => <Icon path={mdiImage} {...props} />}\n                  </ImageControl>\n                </ToolsWrapper>\n              </StyledToolBox>\n            </BlockInsert>\n            <HoverTools>\n              <StyledToolBox>\n                <ToolsWrapper>\n                  <BoldControl>\n                    {props => <Icon path={mdiFormatBold} {...props} />}\n                  </BoldControl>\n                  <ItalicControl>\n                    {props => <Icon path={mdiFormatItalic} {...props} />}\n                  </ItalicControl>\n                  <StrikethroughControl>\n                    {props => <Icon path={mdiFormatStrikethrough} {...props} />}\n                  </StrikethroughControl>\n                  <UnderlineControl>\n                    {props => <Icon path={mdiFormatUnderline} {...props} />}\n                  </UnderlineControl>\n                  <HeadingControl heading=\"h1\">\n                    {props => <Icon path={mdiFormatHeader1} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h2\">\n                    {props => <Icon path={mdiFormatHeader2} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h3\">\n                    {props => <Icon path={mdiFormatHeader3} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h4\">\n                    {props => <Icon path={mdiFormatHeader4} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h5\">\n                    {props => <Icon path={mdiFormatHeader5} {...props} />}\n                  </HeadingControl>\n                  <HeadingControl heading=\"h6\">\n                    {props => <Icon path={mdiFormatHeader6} {...props} />}\n                  </HeadingControl>\n                  <LinkControl>\n                    {props => <Icon path={mdiLink} {...props} />}\n                  </LinkControl>\n                  <TextColorControl\n                    colors={[\n                      \"#d11141\",\n                      \"#00b159\",\n                      \"#00aedb\",\n                      \"#f37735\",\n                      \"#ffc425\",\n                      \"#edc951\",\n                      \"#eb6841\",\n                      \"#cc2a36\",\n                      \"#4f372d\",\n                      \"#00a0b0\"\n                    ]}\n                  >\n                    {props => <Icon path={mdiFormatColorText} {...props} />}\n                  </TextColorControl>\n                </ToolsWrapper>\n              </StyledToolBox>\n            </HoverTools>\n            <Editor\n              spellCheck={false}\n              style={{ overflow: \"auto\", minHeight: 500 }}\n            ></Editor>\n          </div>\n        </Chief>\n      </ContentStyle>\n    </div>\n  );\n}\n\nexport default App;\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Kitchensink from \"./Kitchensink\";\nimport Presentation from \"./Presentation\";\n\nReactDOM.render(<Kitchensink />, document.getElementById(\"root\"));\n"],"sourceRoot":""}