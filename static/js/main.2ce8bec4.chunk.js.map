{"version":3,"sources":["../../src/defaultTheme.tsx","../../src/chief/utils/with-chief-on-plugIn.tsx","../../src/chief/utils/create-editor.tsx","../../src/chief/chief-context.tsx","../../src/chief/chief.tsx","../../src/utils.ts","../../src/override-theme.tsx","../../src/chief/hooks/use-chief.tsx","../../src/chief/handlers/handleRenderLeaf.tsx","../../src/chief/utils/matches-type.tsx","../../src/chief/handlers/handleRenderElement.tsx","../../src/chief/editor.tsx","../../src/chief/handlers/handleDecorate.tsx","../../src/chief/handlers/handleKeyDown.tsx","../../src/chief/handlers/handleKeyUp.tsx","../../src/chief/chief-presentation.tsx","../../src/chief/hooks/use-labels.tsx","../../src/chief/hooks/use-on-key-down.tsx","../../src/chief/hooks/use-plugin.tsx","../../src/chief/hooks/use-render-element.tsx","../../src/chief/hooks/use-render-leaf.tsx","../../src/placeholder-hint.tsx","../../src/leaf-renderer.tsx","../../src/ui/ui-wrap.tsx","../../src/ui/button-base.tsx","../../src/ui/styled-toolbar-btn.tsx","../../src/ToolbarBtn.tsx","../../src/mark-button.tsx","../../src/shortcut.ts","../../src/addons/italic/index.tsx","../../src/addons/underline/index.tsx","../../src/addons/strikethrough/index.tsx","../../src/addons/headings/Heading.tsx","../../src/addons/headings/index.tsx","../../src/addons/hovering-tool/hovering-tool.tsx","../../src/chief/hooks/use-decoration.tsx","../../src/ToolBtnPopup.tsx","../../src/StyledToolBox.tsx","../../src/InputWrapper.tsx","../../src/addons/link/index.tsx","../../src/addons/prevent-newline/index.tsx","../../src/addons/reset-to-paragraph/index.tsx","../../src/addons/labels/index.tsx","../../src/addons/paragraph/paragraph-element.tsx","../../src/addons/paragraph/index.tsx","../../src/addons/bold/index.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/FileUpload.tsx","../../node_modules/ts-is-present/lib/index.js","../../src/show.tsx","../../src/element-wrapper.tsx","../../src/Focused.ts","../../src/ToolsWrapper.tsx","../../src/ui/StyledFocusToolbar.tsx","../../src/ui/WithAttentionToolbar.tsx","../../src/ui/button.tsx","../../src/addons/image/image-element.tsx","../../src/addons/image/index.tsx","../../src/element-utils.ts","../../src/addons/lists/transforms.ts","../../src/element-renderer.tsx","../../src/chief/chief-state.ts","../../src/addons/lists/controls.tsx","../../src/addons/lists/index.tsx","../../src/addons/block-tab/index.tsx","../../src/ToolDivider.tsx","../../src/addons/block-insert-tool/block-insert-controls.tsx","../../src/addons/block-insert-tool/block-insert.tsx","../../src/addons/hovering-tool/hover-tool-controls.tsx","../../src/addons/text-color/index.tsx","App.tsx","index.tsx"],"names":["defaultTheme","colors","primary","seconday","gray","100","200","300","400","500","600","700","800","900","originalEntries","createEditor","plugins","editor","useMemo","withReact","withHistory","createSlateEditor","prop","value","editorFn","plugin","Object","withChiefOnPlugIn","useChiefRenderCore","useState","renderLeafs","setRenderLeafs","renderElements","setRenderElements","injectRenderLeaf","it","removeRenderLeaf","toSlicer","injectRenderElement","removeRenderElement","ChiefContext","React","count","isChiefElement","element","Chief","children","props","onChange","readOnly","id","theme","_theme","merge","chiefValue","injectedPlugins","setInjectedPlugins","injectedLabels","setInjectedLabels","onKeyHandlers","setOnKeyHandlers","decorations","setDecorations","Boolean","setReadOnly","useRef","current","injectOnKeyHandler","a","b","removeOnKeyHandler","onKeyDownHandlers","injectPlugin","removePlugin","OnPlugins","labels","injectLabels","injectDecoration","removeDecoration","useProvideChiefContext","isNodeActive","selection","at","match","n","useOnClickOutside","ref","handler","useEffect","listener","event","document","getNodeFromSelection","path","Editor","getAncestor","level","parent","node","ReactEditor","e","OverrideTheme","name","useChief","ctx","useContext","Error","handleRenderLeaf","copy","leaf","renderLeaf","matchesType","typeMatch","Array","handleRenderElement","renderElement","RichEditor","insertBlock","Transforms","type","text","EditorThemeWrapper","styled","otherProps","useCallback","decorate","ranges","result","handleDecorate","entry","keyDown","isHotkey","handleKeyDown","keyUp","SlateEditor","handleKeyUp","click","paste","clipboardData","onDOMBeforeInput","onKeyDown","onKeyUp","onClick","onPaste","SlatePresentationContext","useSlatePresentation","Element","Children","key","i","child","ChiefPresentation","presenters","overrideRenderElement","overrideRenderLeaf","presenter","overridedElement","overridedLeaf","useLabels","getLabel","label","useOnKeyDown","deps","chief","usePlugin","useRenderElement","ire","useRenderLeaf","irl","PlaceholderHint","leafType","rectType","elementProps","Leaf","attributes","uiStyle","css","UiWrap","ButtonBase","StyledToolbarBtn","ToolbarBtn","onMouseDown","tooltip","containerRef","setValue","handleMouseOver","handleMouseOut","useHover","triggerRef","show","placement","container","target","arrowProps","style","StyledTooltipBody","Arrow","p","Tooltip","toggleFormat","format","isFormatted","isTextFormat","Text","split","MarkBtn","useSlate","isActive","shortcutText","shortcut","toKeyName","italicControl","category","render","defaultLabel","markType","_renderLeaf","Presenter","ItalicAddon","pattern","underlineControl","UnderlineAddon","strikethroughControl","StrikethroughAddon","Heading","useEditor","isFocused","useFocused","isSelected","useSelected","placeholder","h1","h2","h3","h4","h5","h6","isEmpty","undefined","headingTypes","headingBlockControls","headingContextControls","headingType","HeadingsAddon","Range","isHeadingType","HeadingBtn","heading","toggleHeading","hoverToolContext","useHighlightSelection","decoration","useDecoration","decorator","Node","highlightSelection","HoverToolProvider","enabled","saveSelection","perform","setCtx","savedSelection","setSaveSelection","isEditorFocused","isCollapsed","currentNode","isVoid","isReadOnly","backgroundColor","setEnabled","editorRef","sRef","setTimeout","fn","useProvideContext","onChangeEnabled","HoveringTool","deltaOffset","setDeltaOffset","deltaoffset","toolRef","getBoundingClientRect","top","left","bottom","right","width","height","_v","_setV","domNode","err","console","domSelection","window","domRange","modifiers","options","offset","referenceElement","zIndex","ToolBtnPopup","setShow","toolWindow","StyledToolBase","StyledToolBox","Input","InputWrapper","linkControl","Component","isLinkActive","renderContent","onClose","renderToolBtn","tprops","LinkAddon","insertText","isUrl","wrapLink","insertData","data","isInline","isLinkELement","href","url","link","unwrapLink","edge","LinkPopup","useHoverTool","linkWrapperRef","linkNode","_linkNode","setUrl","handleInsertLink","insertLink","handleUnlink","onSubmit","padding","display","minWidth","flexDirection","autoFocus","rounded","disabled","PreventNewlineAddon","ResetToParagraphAddon","deleteBackward","isParagraph","LabelsAddon","ParagraphElement","hoverHint","hint","ParagraphAddon","showHint","showPlaceholder","ParagraphPresenter","boldControl","BoldAddon","action","Symbol","iterator","asyncIterator","HiddenFileInput","FileUpload","defineProperty","exports","t","Show","when","ElementWrapper","attentionChildren","isFocusedWithin","focus","setFocus","Path","inside","setInside","onMouseEnter","onMouseLeave","position","ToolsWrapper","StyledFocusToolBtn","StyledFocusToolbar","WithAttentionToolbar","btns","renderElementProps","marginTop","marginRight","Button","ImageBlock","focused","selected","onOpenFileRequest","onRemoved","embedUrl","setEmbedUrl","isReplacing","setIsReplacing","handleSubmitEmbed","align","handleDelete","handleUpload","handleResize","h","toggleReplace","imageHandler","src","justifyContent","contentEditable","onResize","w","resize","overflow","draggable","objectFit","alt","caption","outline","StyledImageEmptyContainer","isImageElement","imageBlockControls","getAllImageNodes","mode","anchor","findNodes","images","ImageAddon","fileRef","files","file","reader","image","insertImage","imageUrls","JSON","accept","imageRef","dataUrl","HistoryEditor","onUploadRequest","body","recover","then","onUploadedSuccess","error","multiple","toggleList","isElementActive","TYPE_LIST_ITEM","list","getState","point","isSelectionExpanded","isSelectionCollapsed","isElementEmpty","elementType","listControl","TYPE_ORDERED_LIST","TYPE_UNORDERED_LIST","LIST_TYPES","Ul","Ol","Li","_renderElement","ListsAddon","normalizeNode","includes","ancestor","active","getActiveNode","listParent","index","otherList","destination","to","BlockTabAddon","priority","ToolDivider","BlockInsertControls","controls","grouped","groupBy","groupedControls","control","renderButton","BlockInsertBtn","BlockInsert","coords","setCoords","showMenu","setShowMenu","toolboxRef","hoveredNode","setNode","rootNode","firstDOMPoint","useHoveredNode","handleBlockInsert","rect","HoverToolControls","eligableControls","renderControl","TextColorAddon","color","editorLabels","ContentStyle","div","App","addons","log","overrides","ui","marginLeft","Control","hoverTool","spellCheck","margin","minHeight","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.2ce8bec4.chunk.js","sourcesContent":["import { ChiefEditorTheme } from \"./chief-editor-theme\";\n\nexport const defaultTheme: ChiefEditorTheme = {\n  colors: {\n    primary: \"#4299E1\",\n    seconday: \"#38B2AC\",\n    gray: {\n      100: \"#F7FAFC\",\n      200: \"#EDF2F7\",\n      300: \"#E2E8F0\",\n      400: \"#CBD5E0\",\n      500: \"#A0AEC0\",\n      600: \"#718096\",\n      700: \"#4A5568\",\n      800: \"#2D3748\",\n      900: \"#1A202C\"\n    }\n  }\n};\n","import { ReactEditor } from \"slate-react\";\nimport { OnPlugin } from \"../../addon\";\n\n// Use this to save the originals of the editor functions\nlet originalEntries = {};\n/**\n * Allows for dynamically hook in and out of plugins.\n * Only overriding functions of the Editor is supported.\n * @param editor\n * @param plugins\n */\nexport function withChiefOnPlugIn(editor: ReactEditor, plugins: OnPlugin[]) {\n  // We basically take control over each funtion in the editor and route them\n  // to the appropriate addon that has requested overriding it.\n  // This allows for us to use hooks that can mount and unmount.\n  for (const [prop, value] of Object.entries(editor)) {\n    if (typeof value === \"function\") {\n      if (!(prop in originalEntries)) {\n        originalEntries[prop] = value;\n      }\n      editor[prop] = (...args: any[]) => {\n        let editorFn = originalEntries[prop];\n        for (const plugin of plugins) {\n          if (plugin && prop in plugin) {\n            editorFn = plugin && plugin[prop](editorFn, editor);\n          }\n        }\n        return editorFn(...args);\n      };\n    }\n  }\n\n  return editor;\n}\n","import { useMemo } from \"react\";\nimport { ReactEditor, withReact } from \"slate-react\";\nimport { createEditor as createSlateEditor } from \"slate\";\nimport { withHistory } from \"slate-history\";\nimport { OnPlugin } from \"../../addon\";\nimport { withChiefOnPlugIn } from \"./with-chief-on-plugIn\";\n\nexport const createEditor = (plugins: OnPlugin[]): ReactEditor => {\n  const editor = useMemo(() => withReact(withHistory(createSlateEditor())), []);\n  return useMemo(() => withChiefOnPlugIn(editor, plugins), [plugins]);\n};\n","import React, { useState, useRef } from \"react\";\nimport { ReactEditor, Editable } from \"slate-react\";\nimport { OnPlugin } from \"../addon\";\nimport { KeyHandler } from \"./key-handler\";\nimport { createEditor } from \"./utils/create-editor\";\nimport {\n  InjectedRenderLeaf,\n  InjectedRenderElement,\n  InjectedLabels,\n  InjectedDecorator\n} from \"./chief\";\ninterface ChiefRenderCore {\n  injectRenderLeaf: (irl: InjectedRenderLeaf) => void;\n  removeRenderLeaf: (irl: InjectedRenderLeaf) => void;\n  renderLeafs: Array<InjectedRenderLeaf>;\n  injectRenderElement: (irl: InjectedRenderElement<any>) => void;\n  removeRenderElement: (irl: InjectedRenderElement<any>) => void;\n  renderElements: InjectedRenderElement[];\n}\n\nexport function useChiefRenderCore() {\n  const [renderLeafs, setRenderLeafs] = useState<InjectedRenderLeaf[]>([]);\n  const [renderElements, setRenderElements] = useState<InjectedRenderElement[]>(\n    []\n  );\n  function injectRenderLeaf(irl: InjectedRenderLeaf) {\n    setRenderLeafs(it => [...it, irl]);\n  }\n\n  function removeRenderLeaf(irl: InjectedRenderLeaf) {\n    setRenderLeafs(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(toSlicer.indexOf(irl), 1);\n      return toSlicer;\n    });\n  }\n\n  function injectRenderElement(ire: InjectedRenderElement) {\n    setRenderElements(it => [...it, ire]);\n  }\n\n  function removeRenderElement(ire: InjectedRenderElement) {\n    setRenderElements(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(it.indexOf(ire), 1);\n      return toSlicer;\n    });\n  }\n\n  return {\n    renderLeafs,\n    injectRenderLeaf,\n    removeRenderLeaf,\n    renderElements,\n    injectRenderElement,\n    removeRenderElement\n  };\n}\n\nexport interface ChiefContextValue extends ChiefRenderCore {\n  editor: ReactEditor;\n  readOnly: boolean;\n  setReadOnly: (readOnly: boolean) => void;\n  id: string;\n  injectOnKeyHandler: (keyHandler: KeyHandler) => void;\n  removeOnKeyHandler: (keyHandler: KeyHandler) => void;\n  onKeyDownHandlers: KeyHandler[];\n  injectPlugin: (plugin: OnPlugin) => void;\n  removePlugin: (plugin: OnPlugin) => void;\n  OnPlugins: OnPlugin[];\n  labels: InjectedLabels;\n  injectLabels: (labels: InjectedLabels) => void;\n  decorations: InjectedDecorator[];\n  injectDecoration: (decoration: InjectedDecorator) => void;\n  removeDecoration: (decoration: InjectedDecorator) => void;\n}\nexport const ChiefContext = React.createContext<ChiefContextValue | null>(null);\nlet count = 1;\nexport function useProvideChiefContext(props: {\n  readOnly?: boolean;\n  id?: string;\n}) {\n  const [injectedPlugins, setInjectedPlugins] = useState<OnPlugin[]>([]);\n  const [injectedLabels, setInjectedLabels] = useState<InjectedLabels>({});\n  const [onKeyHandlers, setOnKeyHandlers] = useState<KeyHandler[]>([]);\n  const [decorations, setDecorations] = useState<InjectedDecorator[]>([]);\n  const editor = createEditor(injectedPlugins);\n  const [readOnly, setReadOnly] = useState(Boolean(props.readOnly));\n  const { current: id } = useRef(props.id || `chiefeditor${count++}`);\n\n  function injectPlugin(plugin: OnPlugin) {\n    setInjectedPlugins(plugins => [...plugins, plugin]);\n  }\n\n  function removePlugin(plugin: OnPlugin) {\n    setInjectedPlugins(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(toSlicer.indexOf(plugin), 1);\n      return toSlicer;\n    });\n  }\n\n  function injectOnKeyHandler(keyHandler: KeyHandler) {\n    setOnKeyHandlers(it =>\n      [...it, keyHandler].sort((a, b) =>\n        a.priority === b.priority ? 0 : a.priority === \"low\" ? 1 : -1\n      )\n    );\n  }\n\n  function removeOnKeyHandler(keyHandler: KeyHandler) {\n    setOnKeyHandlers(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(it.indexOf(keyHandler), 1);\n      return toSlicer;\n    });\n  }\n\n  function injectDecoration(decorator: InjectedDecorator) {\n    setDecorations(it =>\n      [...it, decorator].sort((a, b) =>\n        a.priority === b.priority ? 0 : a.priority === \"low\" ? 1 : -1\n      )\n    );\n  }\n\n  function removeDecoration(decorator: InjectedDecorator) {\n    setDecorations(it => {\n      const toSlicer = [...it];\n      toSlicer.splice(it.indexOf(decorator), 1);\n      return toSlicer;\n    });\n  }\n\n  function injectLabels(labels: InjectedLabels) {\n    setInjectedLabels(it => ({ ...it, ...labels }));\n  }\n\n  const value: ChiefContextValue = {\n    ...useChiefRenderCore(),\n    editor,\n    readOnly,\n    setReadOnly,\n    id,\n    injectOnKeyHandler,\n    removeOnKeyHandler,\n    onKeyDownHandlers: onKeyHandlers,\n    injectPlugin,\n    removePlugin,\n    OnPlugins: injectedPlugins,\n    labels: injectedLabels,\n    injectLabels,\n    decorations,\n    injectDecoration,\n    removeDecoration\n  };\n\n  return value;\n}\n","import React, { useEffect } from \"react\";\nimport {\n  RenderLeafProps,\n  ReactEditor,\n  RenderElementProps,\n  Slate\n} from \"slate-react\";\nimport { Node, Element, NodeEntry, Range } from \"slate\";\nimport merge from \"lodash/merge\";\nimport { ChiefEditorTheme } from \"../chief-editor-theme\";\nimport { ThemeProvider } from \"styled-components\";\nimport { defaultTheme } from \"../defaultTheme\";\nimport { useProvideChiefContext, ChiefContext } from \"./chief-context\";\n\nexport function isChiefElement(element: unknown): element is ChiefElement {\n  return (element as ChiefElement).type !== undefined;\n}\n\nexport type ChiefElement = Element & {\n  type: string;\n};\n\nexport type ChiefRenderElementProps<\n  T extends ChiefElement = ChiefElement\n> = RenderElementProps & {\n  element: T;\n};\n\nexport type ElementTypeMatch = RegExp | string | string[];\n\nexport type InjectedRenderLeaf = {\n  renderLeaf: (\n    props: RenderLeafProps,\n    editor?: ReactEditor\n  ) => JSX.Element | undefined;\n};\n\nexport type InjectedRenderElement<T extends ChiefElement = ChiefElement> = {\n  typeMatch?: ElementTypeMatch;\n  Component?: React.FunctionComponent<ChiefRenderElementProps>;\n  renderElement?:\n    | JSX.Element\n    | ((\n        props: ChiefRenderElementProps<T>,\n        editor?: ReactEditor\n      ) => JSX.Element | undefined);\n};\n\nexport type InjectedLabels = { [key: string]: string | undefined };\nexport type Label = { key: string; defaultLabel: string };\n\nexport type InjectedDecorator = {\n  decorator: (\n    entry: NodeEntry<Node>,\n    editor: ReactEditor\n  ) => Range[] | undefined;\n  priority?: \"high\" | \"low\";\n};\n\nexport const Chief = React.memo(function(props: {\n  value: Node[];\n  onChange: (value: Node[]) => void;\n  children: React.ReactNode;\n  readOnly?: boolean;\n  id?: string;\n  theme?: ChiefEditorTheme & { [key: string]: any };\n}) {\n  const { children, onChange, value, readOnly, id, theme } = props;\n  const _theme = merge({}, defaultTheme, theme);\n  const chiefValue = useProvideChiefContext({ readOnly, id });\n\n  return (\n    <Slate editor={chiefValue.editor} value={value} onChange={onChange}>\n      <ChiefContext.Provider value={chiefValue}>\n        <ThemeProvider theme={_theme}>\n          <React.Fragment>{children}</React.Fragment>\n        </ThemeProvider>\n      </ChiefContext.Provider>\n    </Slate>\n  );\n});\n","import { useEffect, useCallback, useState, useRef } from \"react\";\nimport { Editor, Point, Node, Transforms, Location } from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nimport { Range } from \"slate\";\n\nexport const isInside = (rect: ClientRect, x: number, y: number) => {\n  return (\n    x >= rect.left &&\n    x <= rect.left + rect.width &&\n    y >= rect.top &&\n    y <= rect.top + rect.height\n  );\n};\n\nexport const useGlobalHover = (element: HTMLElement | null) => {\n  const [over, setOver] = useState(false);\n\n  const handleMove = useCallback(\n    (event: MouseEvent) => {\n      if (element) {\n        const bounds = element.getBoundingClientRect();\n        setOver(isInside(bounds, event.clientX, event.clientY));\n      }\n    },\n    [element]\n  );\n\n  useEffect(() => {\n    window.addEventListener(\"mousemove\", handleMove);\n    return () => {\n      window.removeEventListener(\"mousemove\", handleMove);\n    };\n  }, [element]);\n  return over;\n};\n\nexport function useHover<T extends HTMLElement>(): [\n  React.RefObject<T>,\n  boolean\n] {\n  const [value, setValue] = useState(false);\n\n  const ref = useRef<T>(null);\n\n  const handleMouseOver = () => setValue(true);\n  const handleMouseOut = () => setValue(false);\n\n  useEffect(\n    () => {\n      const node = ref.current;\n      if (node) {\n        node.addEventListener(\"mouseover\", handleMouseOver);\n        node.addEventListener(\"mouseout\", handleMouseOut);\n\n        return () => {\n          node.removeEventListener(\"mouseover\", handleMouseOver);\n          node.removeEventListener(\"mouseout\", handleMouseOut);\n        };\n      }\n      return undefined;\n    },\n    [ref.current] // Recall only if ref changes\n  );\n\n  return [ref, value];\n}\n\nexport const getActiveNode = (editor: ReactEditor) => {\n  if (editor.selection) {\n    const [, path] = Editor.node(editor, editor.selection);\n    if (path.length) {\n      const [parent] = Editor.parent(editor, path);\n      return parent;\n    }\n  }\n  return null;\n};\n\nexport const getActiveNodeType = (editor: ReactEditor) => {\n  const block = getActiveNode(editor);\n  return block ? block.type : null;\n};\n\nexport const clone = (value: any) => {\n  return JSON.parse(JSON.stringify(value));\n};\n\ninterface State {\n  node: Node | null;\n  point: Point | null;\n  selection: Range | null;\n}\n\nexport const useLastFocused = (editor: ReactEditor) => {\n  const [state, setState] = useState<State>({\n    node: null,\n    point: null,\n    selection: null\n  });\n  const { selection } = editor;\n  const current = getActiveNodeType(editor);\n\n  useEffect(() => {\n    if (!ReactEditor.isFocused(editor)) {\n      return;\n    }\n    if (!selection) {\n      return;\n    }\n    if (current) {\n      const point = selection.focus;\n      const [node] = Editor.parent(editor, point);\n      if (Node.isNode(node)) {\n        setState({ node, point, selection: clone(selection) });\n      }\n    }\n  }, [current, selection]);\n\n  return state;\n};\n\nexport const isBlockEmpty = (editor: Editor, location?: Location) => {\n  let selection: Location | null = editor.selection;\n  if (location) {\n    selection = location;\n  }\n  if (selection) {\n    const [node] = Editor.node(editor, selection);\n    return Node.string(node).length === 0;\n  }\n\n  return false;\n};\n\nexport const toggleBlock = (editor: Editor, type: string) => {\n  const isActive = isNodeActive(editor, type);\n\n  Transforms.setNodes(editor, {\n    type: isActive ? \"paragraph\" : type\n  });\n};\n\nexport const isNodeActive = (editor: Editor, type: string) => {\n  const { selection } = editor;\n  if (!selection) {\n    return false;\n  }\n  const [match] = Editor.nodes(editor, {\n    at: selection,\n    match: n => n.type === type\n  });\n  return !!match;\n};\n\nexport function useOnClickOutside(\n  ref: React.MutableRefObject<any>,\n  handler: (event: MouseEvent | TouchEvent) => void\n) {\n  useEffect(\n    () => {\n      const listener = (event: MouseEvent | TouchEvent) => {\n        // Do nothing if clicking ref's element or descendent elements\n        if (!ref.current || ref.current.contains(event.target)) {\n          return;\n        }\n\n        handler(event);\n      };\n\n      document.addEventListener(\"mousedown\", listener);\n      document.addEventListener(\"touchstart\", listener);\n\n      return () => {\n        document.removeEventListener(\"mousedown\", listener);\n        document.removeEventListener(\"touchstart\", listener);\n      };\n    },\n    // Add ref and handler to effect dependencies\n    // It's worth noting that because passed in handler is a new ...\n    // ... function on every render that will cause this effect ...\n    // ... callback/cleanup to run every render. It's not a big deal ...\n    // ... but to optimize you can wrap handler in useCallback before ...\n    // ... passing it into this hook.\n    [ref, handler]\n  );\n}\n\nexport function getNodeFromSelection(editor: Editor, selection: Range | null) {\n  if (selection) {\n    const [, path] = Editor.node(editor, selection);\n    if (path.length) {\n      const [parent] = Editor.parent(editor, path);\n      return parent;\n    }\n  }\n  return null;\n}\n\nexport const findNodes = (editor: Editor, match: (node: Node) => boolean) => {\n  return Editor.nodes(editor, {\n    mode: \"all\",\n    at: {\n      anchor: Editor.start(editor, []),\n      focus: Editor.end(editor, [])\n    },\n    match\n  });\n};\n\nexport const getAncestor = (editor: ReactEditor, node: Node, level = 1) => {\n  let parent: Node | null = null;\n  let count = 0;\n  while (node && count !== level) {\n    count++;\n    try {\n      const path = ReactEditor.findPath(editor, node);\n      if (path.length === 0) {\n        return null;\n      }\n      parent = Editor.parent(editor, path)[0];\n      if (parent === editor) {\n        return null;\n      }\n      node = parent;\n    } catch (e) {}\n  }\n  return parent;\n};\n","import { css } from \"styled-components\";\nexport function OverrideTheme(\n  name: string,\n  props: {\n    theme: {\n      overrides?: {\n        [key: string]: ReturnType<typeof css>;\n      };\n    };\n  }\n) {\n  if (props.theme.overrides && props.theme.overrides[name]) {\n    return props.theme.overrides[name];\n  }\n  return undefined;\n}\n","import { useContext } from \"react\";\nimport { ChiefContext } from \"../chief-context\";\n\nexport function useChief() {\n  const ctx = useContext(ChiefContext);\n  if (!ctx) {\n    throw new Error(\n      'Chief context not found. Wrap your <Chief.Editor/> in a <Chief/> before using \"useChief()\"'\n    );\n  }\n  return ctx;\n}\n","import React from \"react\";\nimport { ReactEditor, RenderLeafProps } from \"slate-react\";\nimport { InjectedRenderLeaf } from \"../chief\";\nexport function handleRenderLeaf(\n  props: RenderLeafProps,\n  renderLeafs: InjectedRenderLeaf[],\n  editor?: ReactEditor\n) {\n  let copy = { ...props };\n  for (const renderLeaf of renderLeafs) {\n    const leaf = renderLeaf.renderLeaf(copy, editor);\n    if (leaf) {\n      copy = { ...copy, children: leaf };\n    }\n  }\n  return <span {...copy.attributes}>{copy.children}</span>;\n}\n","import { ElementTypeMatch, ChiefElement } from \"../chief\";\n\nexport function matchesType(\n  element: ChiefElement,\n  typeMatch?: ElementTypeMatch\n): element is ChiefElement {\n  return (\n    (Array.isArray(typeMatch) && typeMatch.includes(element.type)) ||\n    (typeof typeMatch === \"string\" && typeMatch === element.type) ||\n    Boolean(typeMatch instanceof RegExp && element.type.match(typeMatch))\n  );\n}\n","import React from \"react\";\nimport { ReactEditor } from \"slate-react\";\nimport { InjectedRenderElement, ChiefRenderElementProps } from \"../chief\";\nimport { matchesType } from \"../utils/matches-type\";\n\nexport function handleRenderElement(\n  props: ChiefRenderElementProps,\n  renderElements: InjectedRenderElement[],\n  editor?: ReactEditor\n) {\n  let element: JSX.Element | undefined;\n  for (let renderElement of renderElements) {\n    if (\n      renderElement.typeMatch === undefined ||\n      matchesType(props.element, renderElement.typeMatch)\n    ) {\n      if (renderElement.Component) {\n        element = <renderElement.Component {...props} />;\n      } else if (renderElement.renderElement) {\n        element =\n          typeof renderElement.renderElement === \"function\"\n            ? renderElement.renderElement(props, editor)\n            : React.cloneElement(renderElement.renderElement, props) || element;\n      }\n    }\n  }\n\n  return (element = element || <React.Fragment>{null}</React.Fragment>);\n}\n","import React, { useCallback } from \"react\";\nimport merge from \"lodash/merge\";\nimport orderBy from \"lodash/orderBy\";\nimport { Editor as SlateEditor, NodeEntry, Transforms } from \"slate\";\nimport {\n  Editable,\n  ReactEditor,\n  RenderElementProps,\n  RenderLeafProps\n} from \"slate-react\";\nimport styled from \"styled-components\";\nimport { isNodeActive } from \"../utils\";\nimport { OverrideTheme } from \"../override-theme\";\nimport { ChiefRenderElementProps } from \"./chief\";\nimport { useChief } from \"./hooks/use-chief\";\nimport { handleDecorate } from \"./handlers/handleDecorate\";\nimport { handleClick } from \"./handlers/handleClick\";\nimport { handleKeyUp } from \"./handlers/handleKeyUp\";\nimport { handleKeyDown } from \"./handlers/handleKeyDown\";\nimport { handleRenderLeaf } from \"./handlers/handleRenderLeaf\";\nimport { handleRenderElement } from \"./handlers/handleRenderElement\";\n\nexport const RichEditor = {\n  ...ReactEditor,\n  insertBlock(editor: SlateEditor, blockType: string) {\n    if (!isNodeActive(editor, blockType)) {\n      Transforms.setNodes(editor, {\n        type: blockType,\n        children: [{ text: \"\" }]\n      });\n    } else {\n      Transforms.insertNodes(editor, {\n        type: blockType,\n        children: [{ text: \"\" }]\n      });\n    }\n  }\n};\n\nconst EditorThemeWrapper = styled.div`\n  ${props => OverrideTheme(\"Editor\", props)}\n`;\n\nexport const Editor = React.memo(\n  (\n    props: {\n      children?: React.ReactNode;\n    } & React.ComponentProps<typeof Editable>\n  ) => {\n    const {\n      editor,\n      readOnly,\n      id,\n      renderLeafs,\n      renderElements,\n      onKeyDownHandlers,\n      decorations\n    } = useChief();\n    const { children, ...otherProps } = props;\n\n    const renderElement = useCallback(\n      (props: RenderElementProps) => {\n        return handleRenderElement(\n          props as ChiefRenderElementProps,\n          renderElements,\n          editor\n        );\n      },\n      [renderElements]\n    );\n\n    const renderLeaf = useCallback(\n      (props: RenderLeafProps) => {\n        return handleRenderLeaf(props, renderLeafs, editor);\n      },\n      [renderLeafs]\n    );\n\n    const decorate = useCallback(\n      (entry: NodeEntry) => handleDecorate(entry, editor, decorations),\n      [decorations]\n    );\n\n    const keyDown = useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        return handleKeyDown(event, editor, onKeyDownHandlers);\n      },\n      [onKeyDownHandlers]\n    );\n\n    // TODO\n    const keyUp = useCallback((event: React.KeyboardEvent<HTMLDivElement>) => {\n      handleKeyUp(event, editor);\n    }, []);\n    //TODO\n    const click = useCallback(\n      (event: React.MouseEvent<HTMLElement>) => handleClick(event, editor, []),\n      []\n    );\n\n    const paste = useCallback((event: React.ClipboardEvent<HTMLDivElement>) => {\n      const clipboardData = event.clipboardData;\n      const pastedData = clipboardData.getData(\"Text\");\n      if (!pastedData) {\n        return;\n      }\n      // editor.insertText(pastedData);\n    }, []);\n\n    // TODO\n    const onDOMBeforeInput = useCallback(e => {}, []);\n\n    return (\n      <React.Fragment>\n        <EditorThemeWrapper>\n          {children}\n          <Editable\n            onDOMBeforeInput={onDOMBeforeInput}\n            renderLeaf={renderLeaf}\n            renderElement={renderElement}\n            decorate={decorate}\n            onKeyDown={keyDown}\n            onKeyUp={keyUp}\n            onClick={click}\n            onPaste={paste}\n            readOnly={readOnly}\n            id={`${id}`}\n            {...otherProps}\n          />\n        </EditorThemeWrapper>\n      </React.Fragment>\n    );\n  }\n);\n","import { NodeEntry, Range } from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nimport { InjectedDecorator } from \"../chief\";\n// TODO\nexport const handleDecorate = (\n  entry: NodeEntry,\n  editor: ReactEditor,\n  decorators: InjectedDecorator[]\n) => {\n  let ranges: Range[] = [];\n  for (let decorate of decorators) {\n    const result = decorate.decorator(entry, editor);\n    if (result) {\n      return (ranges = ranges.concat(result));\n    }\n  }\n  return ranges;\n};\n","import React from \"react\";\nimport { ReactEditor } from \"slate-react\";\nimport { KeyHandler } from \"../key-handler\";\nimport isHotkey from \"is-hotkey\";\nexport const handleKeyDown = (\n  event: React.KeyboardEvent<HTMLDivElement>,\n  editor: ReactEditor,\n  onKeyHandlers: KeyHandler[]\n) => {\n  for (let handler of onKeyHandlers) {\n    if (handler.pattern) {\n      if (isHotkey(handler.pattern, event.nativeEvent) &&\n        handler.handler(event.nativeEvent, editor)) {\n        return;\n      }\n    }\n    else {\n      if (handler.handler(event.nativeEvent, editor)) {\n        return;\n      }\n    }\n  }\n};\n","import React from \"react\";\nimport {\n  Editor as SlateEditor,\n  Location\n} from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nexport const handleKeyUp = (\n  event: React.KeyboardEvent<HTMLDivElement>,\n  editor: ReactEditor\n) => {\n  const { selection } = editor;\n  if (!selection) {\n    return;\n  }\n  const [, path] = SlateEditor.node(editor, selection as Location);\n  if (!path.length) {\n    return;\n  }\n  const [parent] = SlateEditor.parent(editor, path);\n  if (parent) {\n    // TODO: implement some kind of trigger\n    // for (let addon of addons) {\n    //   if (addon.triggers) {\n    //     for (let trigger of plugin.triggers) {\n    //       const matches = findMatches(trigger.pattern, trigger.range, editor);\n    //       if (matches.length) {\n    //         plugin.onTrigger && plugin.onTrigger(editor, matches, trigger);\n    //         return;\n    //       }\n    //     }\n    //   }\n    // }\n  }\n};\n","import React, { ReactNode, useCallback, useEffect } from \"react\";\nimport { RenderLeafProps } from \"slate-react\";\nimport { Node } from \"slate\";\nimport { handleRenderElement } from \"./handlers/handleRenderElement\";\nimport {\n  ChiefRenderElementProps,\n  InjectedRenderLeaf,\n  InjectedRenderElement,\n  ChiefElement\n} from \"./chief\";\nimport { handleRenderLeaf } from \"./handlers/handleRenderLeaf\";\nimport { useChiefRenderCore } from \"./chief-context\";\n\nexport type iPresenter<T extends ChiefElement = any> = {\n  element?: InjectedRenderElement<T>;\n  leaf?: InjectedRenderLeaf;\n};\n\ntype PresenterElementProps = Omit<ChiefRenderElementProps, \"attributes\">;\ntype PresenterLeafProps = Omit<RenderLeafProps, \"attributes\">;\ntype PresenterElement = PresenterElementProps[\"element\"];\n\ninterface SlatePresentationContextValue {\n  renderElement: (props: PresenterElementProps) => ReactNode;\n  renderLeaf: (props: PresenterLeafProps) => ReactNode;\n}\n\nconst SlatePresentationContext = React.createContext<SlatePresentationContextValue | null>(\n  null\n);\n\nfunction useSlatePresentation() {\n  const ctx = React.useContext(SlatePresentationContext);\n  if (!ctx) {\n    throw new Error(\"No SlatePresentationContext\");\n  }\n  return ctx;\n}\n\nfunction isElement(value: any) {\n  return value instanceof Object && Array.isArray(value.children);\n}\n\nfunction Element(props: { element: PresenterElement }) {\n  const { renderElement } = useSlatePresentation();\n  const { element } = props;\n  return (\n    <React.Fragment>\n      {renderElement({\n        children: <Children children={element.children} />,\n        element\n      })}\n    </React.Fragment>\n  );\n}\n\nfunction Leaf({ leaf = { text: \"\" } }: any) {\n  const { renderLeaf } = useSlatePresentation();\n\n  return (\n    <React.Fragment>\n      {renderLeaf({\n        children: <span>{leaf.text}</span>,\n        leaf,\n        text: leaf.text\n      })}\n    </React.Fragment>\n  );\n}\n\nfunction Children(props: { children: Node[] }) {\n  const { children } = props;\n  return (\n    <React.Fragment>\n      {children.map((child: any, i: number) => {\n        if (isElement(child)) {\n          return <Element key={i} element={child} />;\n        } else {\n          return <Leaf key={i} leaf={child} />;\n        }\n      })}\n    </React.Fragment>\n  );\n}\n\nexport function ChiefPresentation({\n  value = [],\n  presenters = [],\n  overrideRenderElement,\n  overrideRenderLeaf\n}: {\n  value: Node[];\n  presenters: iPresenter[];\n  overrideRenderElement?: (\n    props: PresenterElementProps\n  ) => JSX.Element | undefined;\n  overrideRenderLeaf?: (props: PresenterLeafProps) => JSX.Element | undefined;\n}) {\n  const {\n    renderLeafs,\n    renderElements,\n    injectRenderElement,\n    injectRenderLeaf\n  } = useChiefRenderCore();\n\n  useEffect(() => {\n    for (const presenter of presenters) {\n      if (presenter.element) {\n        injectRenderElement(presenter.element);\n      }\n      if (presenter.leaf) {\n        injectRenderLeaf(presenter.leaf);\n      }\n    }\n  }, []);\n\n  return (\n    <SlatePresentationContext.Provider\n      value={{\n        renderElement: useCallback(\n          (props: PresenterElementProps) => {\n            const overridedElement =\n              overrideRenderElement && overrideRenderElement(props);\n            if (overridedElement) {\n              return overridedElement;\n            }\n            return handleRenderElement(props as any, renderElements);\n          },\n          [renderElements]\n        ),\n        renderLeaf: useCallback(\n          (props: PresenterLeafProps) => {\n            const overridedLeaf =\n              overrideRenderLeaf && overrideRenderLeaf(props);\n            if (overridedLeaf) {\n              return overridedLeaf;\n            }\n            return handleRenderLeaf(props as any, renderLeafs);\n          },\n          [renderLeafs]\n        )\n      }}\n    >\n      <Children children={value} />\n    </SlatePresentationContext.Provider>\n  );\n}\n","import { useEffect, useCallback } from \"react\";\nimport { InjectedLabels, Label } from \"../chief\";\nimport { useChief } from \"./use-chief\";\n\nexport function useLabels(labels?: InjectedLabels) {\n  const { labels: injectedLabels, injectLabels } = useChief();\n  const getLabel = useCallback(\n    (label: Label) => {\n      if (typeof injectedLabels[label.key] === \"string\") {\n        return injectedLabels[label.key];\n      }\n      return label.defaultLabel;\n    },\n    [injectedLabels]\n  );\n\n  useEffect(() => {\n    if (labels) {\n      injectLabels(labels);\n    }\n  }, []);\n\n  return [getLabel, injectLabels] as const;\n}\n","import { useEffect } from \"react\";\nimport { useChief } from \"./use-chief\";\nimport { KeyHandler } from \"../key-handler\";\n/**\n * Respond to onKeyDown events in the editor.\n * If you want to receive all onKeyDown events, you can leave out the pattern.\n * For responding to certain key down combos, you can specify a key pattern, eg. \"mod+b\".\n * @param handler Function to call when a key or combo is pressed\n * @param overrides\n * @param deps\n */\n\nexport function useOnKeyDown(handler: KeyHandler, deps: any[] = []) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectOnKeyHandler(handler);\n    return () => chief.removeOnKeyHandler(handler);\n  }, deps);\n}\n","import { useEffect } from \"react\";\nimport { OnPlugin } from \"../../addon\";\nimport { useChief } from \"./use-chief\";\n\nexport function usePlugin(plugin: OnPlugin) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectPlugin(plugin);\n    return () => chief.removePlugin(plugin);\n  }, []);\n}\n","import { useEffect } from \"react\";\nimport { ChiefElement, InjectedRenderElement } from \"../chief\";\nimport { useChief } from \"./use-chief\";\n\nexport function useRenderElement<T extends ChiefElement = ChiefElement>(\n  ire: InjectedRenderElement<T>,\n  deps: any[] = []\n) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectRenderElement(ire);\n    return () => chief.removeRenderElement(ire);\n  }, deps);\n}\n","import { useEffect } from \"react\";\nimport { InjectedRenderLeaf } from \"../chief\";\nimport { useChief } from \"./use-chief\";\n\nexport function useRenderLeaf(irl: InjectedRenderLeaf, deps: any[] = []) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectRenderLeaf(irl);\n    return () => chief.removeRenderLeaf(irl);\n  }, deps);\n}\n","import styled from \"styled-components\";\nimport { OverrideTheme } from \"./override-theme\";\n\nexport const PlaceholderHint = styled.span<{\n  isEmpty: boolean;\n  placeholder?: string;\n  hoverHint?: string;\n}>`\n  display: inline-block;\n  width: 100%;\n  ::before {\n    filter: brightness(40%) invert(50%) opacity(0.2) grayscale(100%);\n    content: \"${props =>\n      props.isEmpty && props.placeholder && props.placeholder.length > 0\n        ? props.placeholder\n        : ``}\"\n;\n    pointer-events: none;\n    user-select: none;\n    position: absolute;\n  }\n  &:hover:before {\n    content: \"${props =>\n      props.isEmpty && props.hoverHint && !props.placeholder\n        ? props.hoverHint\n        : props.isEmpty && props.placeholder\n        ? props.placeholder\n        : \"\"}\";\n  }\n  ${props => OverrideTheme(\"PlaceholderHint\", props)}\n`;\n","import React, { memo, ReactNode } from \"react\";\nimport { RenderLeafProps } from \"slate-react\";\n\nexport function renderLeaf(\n  props: RenderLeafProps,\n  leafType: string,\n  rectType: Parameters<typeof React.createElement>[\"0\"],\n  elementProps?: Parameters<typeof React.createElement>[\"1\"]\n) {\n  const { children, leaf } = props;\n  if (leaf[leafType]) {\n    return (\n      <Leaf {...props}>\n        {React.createElement(rectType, elementProps, children)}\n      </Leaf>\n    );\n  }\n  return undefined;\n}\n\nconst Leaf = (props: RenderLeafProps) => {\n  const { attributes, children } = props;\n  return <span {...attributes} children={children} />;\n};\n","import styled, { css } from \"styled-components\";\nimport { OverrideTheme } from \"../override-theme\";\n\nexport const uiStyle = css`\n  font-size: 14px;\n  font-family: Arial, Helvetica, sans-serif;\n  font-weight: normal;\n  ${props => OverrideTheme(\"ui\", props)}\n`;\n\nexport const UiWrap = styled.div`\n  ${uiStyle}\n`;\n","import styled from \"styled-components\";\nimport { OverrideTheme } from \"../override-theme\";\nimport { uiStyle } from \"./ui-wrap\";\nexport const ButtonBase = styled.button`\n  ${uiStyle}\n  line-height: 1.15;\n  margin: 0;\n  cursor: pointer;\n  &:focus {\n    outline: none;\n  }\n  ${props => OverrideTheme(\"ButtonBase\", props)}\n`;\n","import styled from \"styled-components\";\nimport { ButtonBase } from \"./button-base\";\nimport { OverrideTheme } from \"../override-theme\";\n\nexport const StyledToolbarBtn = styled(ButtonBase)<{\n  isActive?: boolean;\n  rounded?: boolean;\n}>`\n  width: 100%;\n  transition: all 250ms;\n  background-color: white;\n  &:hover {\n    background-color: ${props =>\n      props.disabled ? undefined : props.theme.colors.gray[200]};\n  }\n  &:active {\n    background-color: ${props => props.theme.colors.gray[100]};\n  }\n  &:first-child {\n    padding-left: 10px;\n  }\n  &:last-child {\n    padding-right: 10px;\n  }\n  border-radius: ${props => (props.rounded ? \"5px\" : undefined)};\n  padding: 8px;\n  color: ${props => (props.isActive ? props.theme.colors.primary : undefined)};\n  border: none;\n  ${props => OverrideTheme(\"StyledToolbarBtn\", props)}\n`;\n","import React, { useRef } from \"react\";\nimport { StyledToolbarBtn } from \"./ui/styled-toolbar-btn\";\nimport Overlay from \"react-overlays/Overlay\";\nimport { useHover } from \"./utils\";\nimport styled, { css } from \"styled-components\";\nimport { Label } from \"./chief/chief\";\nimport { useLabels } from \"./chief/hooks/use-labels\";\n\nexport type Ref = HTMLElement;\n\ntype Props = {\n  tooltip?: {\n    label: Label;\n    shortcut?: string;\n    placement?: React.ComponentProps<typeof Overlay>[\"placement\"];\n  };\n  onMouseDown?: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  onClick?: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n} & React.ComponentProps<typeof StyledToolbarBtn>;\n\nexport const ToolbarBtn = React.forwardRef<Ref, Props>((props, ref) => {\n  const { onClick, onMouseDown, tooltip, ...otherProps } = props;\n  const containerRef = useRef(null);\n  const [triggerRef, show] = useHover<HTMLDivElement>();\n  const [labels] = useLabels();\n\n  return (\n    <div ref={containerRef}>\n      <div ref={triggerRef}>\n        <StyledToolbarBtn\n          ref={ref}\n          onMouseDown={(e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n            if (onClick) {\n              onClick(e);\n              return;\n            }\n            onMouseDown && onMouseDown(e);\n          }}\n          {...otherProps}\n        />\n      </div>\n      <Overlay\n        show={tooltip && show}\n        placement={tooltip?.placement || \"top\"}\n        container={containerRef}\n        target={triggerRef}\n      >\n        {({ props, arrowProps, placement }) => (\n          <Tooltip {...props} placement={placement}>\n            <Arrow\n              {...arrowProps}\n              placement={placement}\n              style={arrowProps.style}\n            />\n            {tooltip && (\n              <StyledTooltipBody>\n                <div>\n                  <strong>{labels(tooltip.label)}</strong>\n                </div>\n                <div>{tooltip.shortcut}</div>\n              </StyledTooltipBody>\n            )}\n          </Tooltip>\n        )}\n      </Overlay>\n    </div>\n  );\n});\n\nconst StyledTooltipBody = styled.div`\n  font-size: 0.8em;\n  padding: 3px 8px;\n  color: #fff;\n  text-align: center;\n  border-radius: 3px;\n  background-color: #000;\n  div:nth-child(1) {\n  }\n  div:nth-child(2) {\n    font-weight: bold;\n    font-size: 0.7em;\n    color: ${props => props.theme.colors.gray[400]};\n  }\n`;\n\nconst Arrow = styled.div<{ placement: string }>`\n  position: absolute;\n  width: 0;\n  height: 0;\n  border-style: solid;\n\n  ${p => {\n    switch (p.placement) {\n      case \"left\":\n        return css`\n          right: 0;\n          border-width: 5px 0 5px 5px;\n          border-color: transparent transparent transparent #000;\n        `;\n      case \"right\":\n        return css`\n          left: 0;\n          border-width: 5px 5px 5px 0;\n          border-color: transparent #232323 transparent transparent;\n        `;\n      case \"top\":\n        return css`\n          bottom: 0;\n          border-width: 5px 5px 0;\n          border-color: #232323 transparent transparent transparent;\n        `;\n      case \"bottom\":\n        return css`\n          top: 0;\n          border-width: 0 5px 5px;\n          border-color: transparent transparent #232323 transparent;\n        `;\n      default:\n        return \"\";\n    }\n  }}\n`;\n\nconst Tooltip = styled.div<{ placement: string }>`\n  position: absolute;\n  padding: 0 5px;\n\n  ${p => {\n    switch (p.placement) {\n      case \"left\":\n        return css`\n          padding: 0 5px;\n        `;\n      case \"right\":\n        return css`\n          padding: 0 5px;\n        `;\n      case \"top\":\n        return css`\n          padding: 5px 0;\n        `;\n      case \"bottom\":\n        return css`\n          padding: 5px 0;\n        `;\n      default:\n        return \"\";\n    }\n  }}\n`;\n","import React from \"react\";\nimport { useSlate } from \"slate-react\";\nimport { ToolbarBtn } from \"./ToolbarBtn\";\nimport { Editor, Transforms, Text } from \"slate\";\nimport { useLabels } from \"./chief/hooks/use-labels\";\n\nexport function toggleFormat(editor: Editor, format: string) {\n  let isFormatted = isTextFormat(editor, format);\n  Transforms.setNodes(\n    editor,\n    { [format]: !isFormatted },\n    { match: n => Text.isText(n), split: true }\n  );\n}\n\nconst isTextFormat = (editor: Editor, formatType: string) => {\n  const [match] = Editor.nodes(editor, {\n    match: n => Boolean(n[formatType])\n  });\n  return Boolean(match);\n};\n\nexport function MarkBtn(\n  props: {\n    markType: string;\n  } & React.ComponentProps<typeof ToolbarBtn>\n) {\n  const { markType: formatType, ...otherProps } = props;\n  const editor = useSlate();\n  const isActive = isTextFormat(editor, props.markType);\n  return (\n    <ToolbarBtn\n      isActive={isActive}\n      onMouseDown={(e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n        e.preventDefault();\n        toggleFormat(editor, props.markType);\n      }}\n      {...otherProps}\n    />\n  );\n}\n","import { toKeyName } from \"is-hotkey\";\n\nexport function shortcutText(shortcut: string) {\n  return toKeyName(shortcut).replace(\"mod\", \"⌘\").toUpperCase();\n}\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { MarkBtn, toggleFormat } from \"../../mark-button\";\nimport { useRenderLeaf } from \"../../chief/hooks/use-render-leaf\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { shortcutText } from \"../../shortcut\";\nimport { Control } from \"../../control\";\nimport { InjectedRenderLeaf } from \"../../chief\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\n\nconst shortcut = \"mod+i\";\n\nexport const italicControl: Control = {\n  category: \"marks\",\n  render: () => {\n    return (\n      <MarkBtn\n        tooltip={{\n          label: {\n            key: \"marks.italic\",\n            defaultLabel: \"Italic\"\n          },\n          shortcut: shortcutText(shortcut)\n        }}\n        markType=\"italic\"\n      >\n        I\n      </MarkBtn>\n    );\n  }\n};\n\nconst _renderLeaf: InjectedRenderLeaf = {\n  renderLeaf: props => renderLeaf(props, \"italic\", \"em\")\n};\n\nconst Presenter: iPresenter = {\n  leaf: _renderLeaf\n};\n\nexport function ItalicAddon(props: AddonProps) {\n  useLabels(props.labels);\n  useRenderLeaf(_renderLeaf);\n  useOnKeyDown({\n    pattern: shortcut,\n    handler: (event, editor) => {\n      event.preventDefault();\n      toggleFormat(editor, \"italic\");\n      return true;\n    }\n  });\n  return null;\n}\n\nItalicAddon.Presenter = Presenter;\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { MarkBtn, toggleFormat } from \"../../mark-button\";\nimport { useRenderLeaf } from \"../../chief/hooks/use-render-leaf\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { shortcutText } from \"../../shortcut\";\nimport { Control } from \"../../control\";\nimport { InjectedRenderLeaf } from \"../../chief\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\n\nconst shortcut = \"mod+u\";\n\nexport const underlineControl: Control = {\n  category: \"marks\",\n  render: () => {\n    return (\n      <MarkBtn\n        tooltip={{\n          label: {\n            key: \"marks.underline\",\n            defaultLabel: \"Underline\"\n          },\n          shortcut: shortcutText(shortcut)\n        }}\n        markType=\"underline\"\n      >\n        U\n      </MarkBtn>\n    );\n  }\n};\n\nconst _renderLeaf: InjectedRenderLeaf = {\n  renderLeaf: props => renderLeaf(props, \"underline\", \"u\")\n};\n\nconst Presenter: iPresenter = {\n  leaf: _renderLeaf\n};\n\nexport function UnderlineAddon(props: AddonProps) {\n  useLabels(props.labels);\n  useRenderLeaf(_renderLeaf);\n  useOnKeyDown({\n    pattern: shortcut,\n    handler: (event, editor) => {\n      event.preventDefault();\n      toggleFormat(editor, \"underline\");\n      return true;\n    }\n  });\n  return null;\n}\n\nUnderlineAddon.Presenter = Presenter;\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { MarkBtn, toggleFormat } from \"../../mark-button\";\nimport { useRenderLeaf } from \"../../chief/hooks/use-render-leaf\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { shortcutText } from \"../../shortcut\";\nimport { Control } from \"../../control\";\nimport { InjectedRenderLeaf } from \"../../chief\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\n\nconst shortcut = \"mod+s\";\n\nexport const strikethroughControl: Control = {\n  category: \"marks\",\n  render: () => {\n    return (\n      <MarkBtn\n        tooltip={{\n          label: {\n            key: \"marks.strikethrough\",\n            defaultLabel: \"Strike-through\"\n          },\n          shortcut: shortcutText(shortcut)\n        }}\n        markType=\"strikethrough\"\n      >\n        S\n      </MarkBtn>\n    );\n  }\n};\n\nconst _renderLeaf: InjectedRenderLeaf = {\n  renderLeaf: props => renderLeaf(props, \"strikethrough\", \"s\")\n};\n\nconst Presenter: iPresenter = {\n  leaf: _renderLeaf\n};\n\nexport function StrikethroughAddon(props: AddonProps) {\n  useLabels(props.labels);\n  useRenderLeaf(_renderLeaf);\n  useOnKeyDown({\n    pattern: shortcut,\n    handler: (event, editor) => {\n      event.preventDefault();\n      toggleFormat(editor, \"strikethrough\");\n      return true;\n    }\n  });\n  return null;\n}\n\nStrikethroughAddon.Presenter = Presenter;\n","import React from \"react\";\nimport { useFocused, useSelected, useEditor } from \"slate-react\";\nimport { PlaceholderHint } from \"../../placeholder-hint\";\nimport { Editor } from \"slate\";\nimport { useLabels, ChiefRenderElementProps } from \"../../chief\";\n\nexport const Heading = (props: ChiefRenderElementProps) => {\n  const editor = useEditor();\n  const isFocused = useFocused();\n  const isSelected = useSelected();\n  const defaultPlaceholderTexts = {\n    h1: \"Heading 1\",\n    h2: \"Heading 2\",\n    h3: \"Heading 3\",\n    h4: \"Heading 4\",\n    h5: \"Heading 5\",\n    h6: \"Heading 6\"\n  };\n  const [getLabel] = useLabels();\n  let placeholder = getLabel({\n    key: `elements.heading.${props.element.type}.placeholder`,\n    defaultLabel: defaultPlaceholderTexts[props.element.type]\n  });\n\n  return React.createElement(\n    props.element.type,\n    props.attributes,\n    <PlaceholderHint\n      isEmpty={Editor.isEmpty(editor, props.element)}\n      placeholder={isFocused && isSelected ? placeholder : undefined}\n    >\n      {props.children}\n    </PlaceholderHint>\n  );\n};\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { Heading } from \"./Heading\";\nimport { Transforms, Editor, Range, Element } from \"slate\";\nimport { useSlate, ReactEditor } from \"slate-react\";\nimport { isNodeActive } from \"../../utils\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { RichEditor } from \"../../chief/editor\";\nimport { Control } from \"../../control\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\n\nexport const headingTypes = [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"];\n\nexport const headingBlockControls: Control[] = [\n  {\n    category: \"headings\",\n    render: editor => (\n      <React.Fragment>\n        {headingTypes.map((it, i) => (\n          <ToolbarBtn\n            isActive={isNodeActive(editor, it)}\n            onMouseDown={(\n              e: React.MouseEvent<HTMLButtonElement, MouseEvent>\n            ) => {\n              ReactEditor.focus(editor);\n              RichEditor.insertBlock(editor, it);\n            }}\n          >\n            {`H${i + 1}`}\n          </ToolbarBtn>\n        ))}\n      </React.Fragment>\n    )\n  }\n];\n\nexport const headingContextControls: Control[] = [\n  {\n    category: \"headings\",\n    render: () => (\n      <React.Fragment>\n        {headingTypes.map((it, i) => (\n          <HeadingBtn headingType={it}>{`H${i + 1}`}</HeadingBtn>\n        ))}\n      </React.Fragment>\n    )\n  }\n];\n\nconst Presenter: iPresenter = {\n  element: {\n    typeMatch: headingTypes,\n    renderElement: props =>\n      React.createElement(props.element.type, null, props.children)\n  }\n};\n\nexport function HeadingsAddon(props: AddonProps) {\n  useRenderElement({\n    typeMatch: headingTypes,\n    renderElement: props => <Heading {...props} />\n  });\n  useOnKeyDown({\n    pattern: \"Enter\",\n    handler: (event, editor) => {\n      const { selection } = editor;\n      if (selection && Range.isCollapsed(selection)) {\n        const [match] = Editor.nodes(editor, {\n          match: n =>\n            typeof n.type === \"string\" &&\n            Boolean(n.type?.match(/(h[1-6])/))\n        });\n        if (match) {\n          event.preventDefault();\n          const [node] = match;\n          if (Element.isElement(node) && Editor.isEmpty(editor, node)) {\n            Transforms.setNodes(editor, { type: \"paragraph\" });\n          } else {\n            Transforms.insertNodes(editor, {\n              type: \"paragraph\",\n              children: [{ text: \"\" }]\n            });\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n  });\n  return null;\n}\n\nfunction toggleHeading(editor: Editor, heading: string) {\n  const isHeaderOfType = isHeadingType(editor, heading);\n  if (isHeaderOfType) {\n    Transforms.setNodes(editor, {\n      type: \"paragraph\"\n    });\n  } else {\n    Transforms.setNodes(editor, {\n      type: heading\n    });\n  }\n}\n\nexport const isHeadingType = (editor: Editor, header: string) => {\n  const [match] = Editor.nodes(editor, {\n    match: n => n.type === header\n  });\n  return Boolean(match);\n};\n\nfunction insertHeader(editor: Editor, heading: string) {\n  Transforms.insertNodes(editor, {\n    type: heading,\n    children: [{ text: \"\" }]\n  });\n}\n\nfunction HeadingBtn(props: { headingType: string; children: React.ReactNode }) {\n  const editor = useSlate();\n  const isActive = isHeadingType(editor, props.headingType);\n  return (\n    <ToolbarBtn\n      isActive={isActive}\n      onMouseDown={(e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n        e.preventDefault();\n        toggleHeading(editor, props.headingType);\n      }}\n    >\n      {props.children}\n    </ToolbarBtn>\n  );\n}\n\nHeadingsAddon.Presenter = Presenter;\n","import React, {\n  useEffect,\n  useState,\n  useRef,\n  useContext,\n  useCallback\n} from \"react\";\nimport { ReactEditor, useSlate, useEditor } from \"slate-react\";\nimport { Editor, Range, Node, Transforms, RangeRef } from \"slate\";\nimport { Popper } from \"react-popper\";\nimport { VirtualElement } from \"@popperjs/core\";\nimport { useOnClickOutside, getNodeFromSelection } from \"../../utils\";\nimport { useDecoration } from \"../../chief/hooks/use-decoration\";\nimport { useRenderLeaf } from \"../../chief\";\nimport { useChief } from \"../../chief/hooks/use-chief\";\n\nexport const deselect = Transforms.deselect;\nTransforms.deselect = (...args) => {\n  // We disable the default deselect.\n};\n\ntype HoverToolContext = {\n  activeNode?: Node;\n  enabled: boolean;\n  saveSelection: (selection: Range | null) => () => void;\n  perform: (fn: (selection: Range) => void) => void;\n};\n\nconst hoverToolContext = React.createContext<HoverToolContext | undefined>(\n  undefined\n);\n\nfunction useHighlightSelection(\n  selection: Range | null | undefined,\n  style: React.CSSProperties\n) {\n  useRenderLeaf(\n    {\n      renderLeaf: props => {\n        return (\n          <span\n            style={props.leaf.highlightSelection ? style : undefined}\n            {...props.attributes}\n          >\n            {props.children}\n          </span>\n        );\n      }\n    },\n    [selection]\n  );\n\n  useDecoration(\n    {\n      decorator: ([node]) => {\n        const ranges: Range[] = [];\n        if (selection && Node.has(node, selection.anchor.path)) {\n          ranges.push({ ...selection, highlightSelection: true });\n        }\n        return ranges;\n      }\n    },\n    [selection]\n  );\n}\n\nfunction useProvideContext() {\n  const editor = useSlate();\n  const { selection } = editor;\n  const [ctx, setCtx] = useState<HoverToolContext>({\n    enabled: false,\n    saveSelection: () => () => null,\n    perform: () => () => null\n  });\n  const [savedSelection, setSaveSelection] = useState<RangeRef | null>(null);\n  const isEditorFocused = ReactEditor.isFocused(editor);\n  const isCollapsed = selection && Range.isCollapsed(selection);\n  const isEmpty = selection && Editor.string(editor, selection) === \"\";\n  const currentNode = getNodeFromSelection(editor, selection);\n  const isVoid = Editor.isVoid(editor, currentNode);\n  const isReadOnly = useChief().readOnly;\n  useHighlightSelection(savedSelection?.current, {\n    backgroundColor: \"#969696\"\n  });\n\n  // console.log({\n  //   isEditorFocused,\n  //   selection,\n  //   isCollapsed,\n  //   isEmpty,\n  //   isVoid,\n  //   ...ctx\n  // });\n\n  const setEnabled = useCallback((enabled: boolean) => {\n    setCtx(ctx => ({\n      ...ctx,\n      enabled\n    }));\n  }, []);\n\n  useEffect(() => {\n    if (isReadOnly) {\n      setEnabled(false);\n    } else if (ctx.enabled) {\n      if (!savedSelection?.current && isCollapsed && !isVoid) {\n        setEnabled(false);\n      }\n    } else {\n      if (isEditorFocused) {\n        if (isCollapsed && isVoid) {\n          setEnabled(true);\n        } else if (!isCollapsed && !isEmpty) {\n          setEnabled(true);\n        }\n      }\n    }\n  }, [isEditorFocused, isCollapsed, isEmpty, isVoid]);\n\n  const editorRef = useRef(editor);\n  editorRef.current = editor;\n\n  const saveSelection = useCallback((selection: Range | null) => {\n    if (selection) {\n      const sRef = Editor.rangeRef(editor, selection);\n      setSaveSelection(sRef);\n      return () => {\n        if (sRef.current) {\n          setTimeout(() => {\n            ReactEditor.focus(editorRef.current);\n            Transforms.select(editorRef.current, sRef.current!);\n            setSaveSelection(null);\n            sRef.unref();\n          }, 0);\n        }\n      };\n    }\n    return () => null;\n  }, []);\n\n  useEffect(() => setCtx(ctx => ({ ...ctx, saveSelection })), []);\n\n  const perform = useCallback(\n    (fn: (selection: Range) => void) => {\n      if (savedSelection && savedSelection.current) {\n        Transforms.select(editorRef.current, savedSelection.current);\n        fn(savedSelection.current);\n      }\n    },\n    [savedSelection]\n  );\n  useEffect(() => setCtx(ctx => ({ ...ctx, perform })), [perform]);\n\n  return { ctx, setEnabled };\n}\n\nexport function useHoverTool() {\n  const ctx = useContext(hoverToolContext);\n  if (ctx === undefined) {\n    throw new Error(\"useHoverTool must be within a <HoverToolProvider/>\");\n  }\n  return ctx;\n}\n\nexport function HoverToolProvider(props: {\n  children?: React.ReactNode;\n  hoverTool: React.ReactNode;\n}) {\n  const { ctx, setEnabled } = useProvideContext();\n  return (\n    <hoverToolContext.Provider value={ctx}>\n      <HoveringTool\n        onChangeEnabled={enabled => setEnabled(enabled)}\n        enabled={ctx.enabled}\n      >\n        {props.hoverTool}\n      </HoveringTool>\n      {props.children}\n    </hoverToolContext.Provider>\n  );\n}\n\nexport const HoveringTool = (\n  props: {\n    children?: React.ReactNode;\n    enabled: boolean;\n    onChangeEnabled: (enabled: boolean) => void;\n  } & React.HTMLProps<HTMLDivElement>\n) => {\n  const { children, enabled, onChangeEnabled, ...otherProps } = props;\n  const editor = useSlate();\n  const { selection } = editor;\n  const [deltaOffset, setDeltaOffset] = useState(-1);\n  const currentNode = getNodeFromSelection(editor, selection);\n\n  useEffect(() => {\n    const deltaoffset = selection\n      ? selection.focus.offset - selection.anchor.offset\n      : -1;\n    setDeltaOffset(deltaoffset);\n  }, [selection]);\n\n  const toolRef = useRef(null);\n  const [_v, _setV] = useState<VirtualElement>({\n    getBoundingClientRect: () => ({\n      top: -1000,\n      left: -1000,\n      bottom: 0,\n      right: 0,\n      width: 1,\n      height: 1\n    })\n  });\n\n  useOnClickOutside(toolRef, e => {\n    if (currentNode) {\n      const domNode = ReactEditor.toDOMNode(editor, currentNode);\n      if (e.target && domNode.contains(e.target as globalThis.Node)) {\n        return;\n      }\n    }\n    onChangeEnabled(false);\n  });\n\n  useEffect(() => {\n    if (enabled) {\n      const isVoid = Editor.isVoid(editor, currentNode);\n      if (isVoid && currentNode) {\n        try {\n          const domNode = ReactEditor.toDOMNode(editor, currentNode);\n          _setV({\n            getBoundingClientRect: () => domNode.getBoundingClientRect()\n          });\n        } catch (err) {\n          console.log(err);\n        }\n      } else {\n        try {\n          const domSelection = window.getSelection();\n          if (domSelection && domSelection.rangeCount > 0) {\n            const domRange = domSelection.getRangeAt(0);\n            if (domRange && deltaOffset !== -1) {\n              _setV({\n                getBoundingClientRect: () => domRange.getBoundingClientRect()\n              });\n            }\n          }\n        } catch (err) {\n          console.log(err);\n        }\n      }\n    }\n  }, [enabled, deltaOffset, selection, currentNode]);\n\n  if (!enabled || !children) {\n    return null;\n  }\n\n  return (\n    <Popper\n      modifiers={[\n        {\n          name: \"offset\",\n          options: {\n            offset: [0, 10]\n          }\n        }\n      ]}\n      placement=\"top-end\"\n      referenceElement={_v}\n    >\n      {({ ref, style, placement, arrowProps }) => (\n        <div\n          ref={ref}\n          style={{ ...style, zIndex: 10 }}\n          data-placement={placement}\n        >\n          <div ref={toolRef} {...otherProps}>\n            {children}\n          </div>\n          <div ref={arrowProps.ref} style={arrowProps.style} />\n        </div>\n      )}\n    </Popper>\n  );\n};\n","import { useEffect } from \"react\";\nimport { useChief } from \"./use-chief\";\nimport { InjectedDecorator } from \"../chief\";\n\nexport function useDecoration(decoration: InjectedDecorator, deps: any[] = []) {\n  const chief = useChief();\n  useEffect(() => {\n    chief.injectDecoration(decoration);\n    return () => chief.removeDecoration(decoration);\n  }, deps);\n}\n","import React, { useState, useRef } from \"react\";\nimport { Popper, Manager, Reference } from \"react-popper\";\nimport { useOnClickOutside } from \"./utils\";\nimport { useOnKeyDown } from \"./chief\";\n\nexport function ToolBtnPopup(props: {\n  shortcut?: string;\n  renderContent: (setShow: (show: boolean) => void) => React.ReactNode;\n  renderToolBtn: (\n    props: {\n      ref: React.Ref<any>;\n      onMouseDown: (e: React.MouseEvent) => void;\n    },\n    show: boolean\n  ) => React.ReactNode;\n}) {\n  const [show, setShow] = useState(false);\n  const toolWindow = useRef(null);\n  useOnClickOutside(toolWindow, e => {\n    if (!e.defaultPrevented) {\n      setShow(false);\n    }\n    e.preventDefault();\n  });\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n    if (e.keyCode === 27) {\n      setShow(false);\n    }\n  };\n  useOnKeyDown({\n    pattern: props.shortcut,\n    handler: () => setShow(!show)\n  });\n  return (\n    <Manager>\n      <Reference>\n        {({ ref }) =>\n          props.renderToolBtn(\n            {\n              ref,\n              onMouseDown: e => {\n                e.preventDefault();\n                setShow(!show);\n              }\n            },\n            show\n          )\n        }\n      </Reference>\n      <Popper\n        placement=\"bottom-start\"\n        modifiers={[\n          {\n            name: \"offset\",\n            options: {\n              offset: [-100, 10]\n            }\n          }\n        ]}\n      >\n        {({ ref, style, placement, arrowProps }) => (\n          <div ref={ref} style={style} data-placement={placement}>\n            {show && (\n              <div onKeyDown={handleKeyDown} ref={toolWindow}>\n                {props.renderContent(setShow)}\n              </div>\n            )}\n            <div ref={arrowProps.ref} style={arrowProps.style} />\n          </div>\n        )}\n      </Popper>\n    </Manager>\n  );\n}\n","import styled from \"styled-components\";\nimport { OverrideTheme } from \"./override-theme\";\nimport { UiWrap } from \"./ui/ui-wrap\";\n\nexport const StyledToolBase = styled(UiWrap)`\n  overflow: hidden;\n  border-radius: 3px;\n  box-shadow: rgba(15, 15, 15, 0.05) 0px 0px 0px 1px,\n    rgba(15, 15, 15, 0.1) 0px 3px 6px, rgba(15, 15, 15, 0.2) 0px 9px 24px;\n`;\n\nexport const StyledToolBox = styled(StyledToolBase)`\n  background-color: white;\n  ${props => OverrideTheme(\"StyledToolBox\", props)}\n`;\n","import styled from \"styled-components\";\n\nexport const Input = styled.input.attrs(props => ({}))`\n  &:focus {\n    outline: 0;\n  }\n  font-size: inherit;\n  line-height: inherit;\n  border: none;\n  background: none;\n  width: 100%;\n  display: block;\n  resize: none;\n  padding: 0px;\n`;\n\nexport const InputWrapper = styled.div.attrs(props => ({\n  \"data-slate-editor\": true\n}))`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  font-size: 14px;\n  line-height: 20px;\n  padding: 4px 10px;\n  position: relative;\n  border-radius: 3px;\n  box-shadow: rgba(15, 15, 15, 0.1) 0px 0px 0px 1px inset,\n    rgba(15, 15, 15, 0.1) 0px 1px 1px inset;\n  background: rgba(242, 241, 238, 0.6);\n  cursor: text;\n  flex-grow: 1;\n  flex-shrink: 1;\n  margin-right: 8px;\n  ${Input} {\n  }\n`;\n","import React, { useEffect, useRef, useState, useCallback } from \"react\";\nimport {\n  RenderElementProps,\n  ReactEditor,\n  useSlate,\n  useEditor\n} from \"slate-react\";\nimport { Element, Editor, Transforms, Range, Node } from \"slate\";\nimport { AddonProps } from \"../../addon\";\nimport isUrl from \"is-url\";\nimport { useHoverTool } from \"../hovering-tool/hovering-tool\";\nimport { ToolBtnPopup } from \"../../ToolBtnPopup\";\nimport { useOnClickOutside } from \"../../utils\";\nimport { StyledToolBox } from \"../../StyledToolBox\";\nimport { InputWrapper, Input } from \"../../InputWrapper\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { usePlugin } from \"../../chief/hooks/use-plugin\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { Control } from \"../../control\";\nimport { ChiefElement } from \"../../chief\";\nimport { shortcutText } from \"../../shortcut\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\n\nexport const isLinkELement = (element: Element) => {\n  return element.type === \"link\" && typeof element.url === \"string\";\n};\n\nexport const linkControl: Control = {\n  category: \"link\",\n  Component: LinkBtn\n};\n\nexport function LinkAddon(props: AddonProps) {\n  useLabels(props.labels);\n  usePlugin({\n    insertText: (insertText, editor) => text => {\n      if (text && isUrl(text)) {\n        wrapLink(editor, text);\n      } else {\n        insertText(text);\n      }\n    },\n    insertData: (insertData, editor) => data => {\n      const text = data.getData(\"text/plain\");\n      if (text && isUrl(text)) {\n        wrapLink(editor, text);\n      } else {\n        insertData(data);\n      }\n    },\n    isInline: isInline => element => {\n      // console.log(\"isInline, link\");\n      return isLinkELement(element) ? true : isInline(element);\n    }\n  });\n\n  useRenderElement<{ url: string } & ChiefElement>({\n    typeMatch: \"link\",\n    renderElement: props => (\n      <a {...props.attributes} href={props.element.url}>\n        {props.children}\n      </a>\n    )\n  });\n  return null;\n}\n\nconst Presenter: iPresenter<{ url: string } & ChiefElement> = {\n  element: {\n    typeMatch: \"link\",\n    renderElement: props => <a href={props.element.url}>{props.children}</a>\n  }\n};\n\nLinkAddon.Presenter = Presenter;\n\nLinkAddon.Control = linkControl;\n\nexport const insertLink = (editor: Editor, url: string) => {\n  if (editor.selection) {\n    wrapLink(editor, url);\n  }\n};\n\nexport const isLinkActive = (editor: Editor) => {\n  const [link] = Editor.nodes(editor, { match: n => n.type === \"link\" });\n  return Boolean(link);\n};\n\nconst unwrapLink = (editor: Editor) => {\n  Transforms.unwrapNodes(editor, { match: n => n.type === \"link\" });\n};\n\nconst wrapLink = (editor: Editor, url: string) => {\n  if (isLinkActive(editor)) {\n    unwrapLink(editor);\n  }\n\n  const { selection } = editor;\n  const isCollapsed = selection && Range.isCollapsed(selection);\n  const link = {\n    type: \"link\",\n    url,\n    children: isCollapsed ? [{ text: url }] : []\n  };\n\n  if (isCollapsed) {\n    Transforms.insertNodes(editor, link);\n  } else {\n    Transforms.wrapNodes(editor, link, { split: true });\n    Transforms.collapse(editor, { edge: \"end\" });\n  }\n};\n\nfunction LinkPopup(props: { onClose: () => void }) {\n  const editor = useSlate();\n  const { selection } = editor;\n  const { saveSelection } = useHoverTool();\n  useEffect(() => {\n    return saveSelection(selection);\n  }, []);\n  const linkWrapperRef = useRef<HTMLDivElement>(null);\n  useOnClickOutside(linkWrapperRef, e => {\n    props.onClose();\n  });\n  let linkNode: Node | null = null;\n  if (selection) {\n    const [_linkNode] = Editor.nodes(editor, {\n      at: selection,\n      match: n => n.type === \"link\"\n    });\n    linkNode = _linkNode && _linkNode[0];\n  }\n  const [url, setUrl] = useState(\"\");\n  useEffect(() => {\n    if (linkNode && typeof linkNode.url === \"string\") {\n      setUrl(linkNode.url);\n    }\n  }, [linkNode]);\n  const handleInsertLink = useCallback(() => {\n    debugger\n    if (url.length > 0) {\n      insertLink(editor, url);\n      props.onClose();\n    } else if (\n      linkNode &&\n      typeof linkNode.url === \"string\" &&\n      linkNode.url.length > 0\n    ) {\n      unwrapLink(editor);\n      props.onClose();\n    }\n  }, [url]);\n\n  const handleUnlink = useCallback(() => {\n    unwrapLink(editor);\n    props.onClose();\n  }, [url]);\n\n  const [getLabel] = useLabels();\n\n  return (\n    <form onSubmit={handleInsertLink}>\n      <div\n        ref={linkWrapperRef}\n        style={{\n          padding: 9,\n          display: \"flex\",\n          minWidth: 400,\n          flexDirection: \"row\"\n        }}\n      >\n        <InputWrapper>\n          <Input\n            value={url}\n            onChange={(e: React.FormEvent<HTMLInputElement>) =>\n              setUrl(e.currentTarget.value)\n            }\n            placeholder={getLabel({\n              key: \"elements.link.placeholder\",\n              defaultLabel: \"Paste or type your link here\"\n            })}\n            autoFocus\n          />\n        </InputWrapper>\n        <ToolbarBtn\n          rounded\n          disabled={url.length === 0}\n          onMouseDown={handleInsertLink}\n        >\n          {getLabel({\n            key: \"elements.link.btn.link\",\n            defaultLabel: \"Link\"\n          })}\n        </ToolbarBtn>\n        <ToolbarBtn\n          rounded\n          disabled={\n            !isLinkActive(editor)\n            // || (linkNode &&\n            //   typeof linkNode.url === \"string\" &&\n            //   linkNode.url.length > 0)\n          }\n          onMouseDown={handleUnlink}\n        >\n          {getLabel({\n            key: \"elements.link.btn.unlink\",\n            defaultLabel: \"Unlink\"\n          })}\n        </ToolbarBtn>\n      </div>\n    </form>\n  );\n}\n\nexport function LinkBtn() {\n  const editor = useEditor();\n  const isActive = isLinkActive(editor);\n  return (\n    <ToolBtnPopup\n      shortcut={\"mod+k\"}\n      renderContent={setShow => (\n        <StyledToolBox>\n          <LinkPopup onClose={() => setShow(false)}></LinkPopup>\n        </StyledToolBox>\n      )}\n      renderToolBtn={(tprops, show) => (\n        <ToolbarBtn\n          tooltip={{\n            label: {\n              key: \"elements.link\",\n              defaultLabel: \"Add link\"\n            },\n            shortcut: shortcutText(\"mod+k\")\n          }}\n          {...tprops}\n          isActive={isActive || show}\n        >\n          Link\n        </ToolbarBtn>\n      )}\n    />\n  );\n}\n","import { AddonProps } from \"../../addon\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { Range } from \"slate\";\n\nexport function PreventNewlineAddon(props: AddonProps) {\n  useOnKeyDown({\n    pattern: \"enter+shift\",\n    handler: (event, editor) => {\n      if (editor.selection && Range.isCollapsed(editor.selection)) {\n        event.preventDefault();\n        event.stopPropagation();\n        editor.insertText(\"\\n\");\n        return true;\n      }\n      return false;\n    }\n  });\n  return null;\n}\n","import { Editor, Transforms, Range } from \"slate\";\nimport { usePlugin } from \"../../chief/hooks/use-plugin\";\n\nexport function ResetToParagraphAddon() {\n  usePlugin({\n    deleteBackward: (deleteBackward, editor) => (...args) => {\n      const { selection } = editor;\n      if (selection && Range.isCollapsed(selection)) {\n        const [parent, path] = Editor.parent(editor, selection);\n        const isParagraph = parent.type === \"paragraph\";\n        if (\n          path.length === 1 &&\n          !isParagraph &&\n          selection &&\n          selection.focus.offset === 0\n        ) {\n          return Transforms.setNodes(editor, { type: \"paragraph\" });\n        }\n      }\n      return deleteBackward(...args);\n    }\n  });\n  return null;\n}\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\n\nexport function LabelsAddon(props: Pick<AddonProps, \"labels\">) {\n  useLabels(props.labels);\n  return null;\n}\n","import React from \"react\";\nimport { Editor as SlateEditor, Range } from \"slate\";\nimport {\n  RenderElementProps,\n  useFocused,\n  useSelected,\n  useSlate\n} from \"slate-react\";\nimport { PlaceholderHint } from \"../../placeholder-hint\";\nimport { ChiefRenderElementProps } from \"../../chief/chief\";\n\nexport function ParagraphElement(\n  props: ChiefRenderElementProps & { placeholder?: string; hint?: string }\n) {\n  const editor = useSlate();\n  const isFocused = useFocused();\n  const isSelected = useSelected();\n  return (\n    <p {...props.attributes}>\n      <PlaceholderHint\n        isEmpty={SlateEditor.isEmpty(editor, props.element)}\n        hoverHint={props.hint}\n        placeholder={isFocused && isSelected ? props.placeholder : undefined}\n      >\n        {React.Children.map(props.children, it => it)}\n      </PlaceholderHint>\n    </p>\n  );\n}\n","import React from \"react\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { Element } from \"slate\";\nimport { ParagraphElement } from \"./paragraph-element\";\nimport { useLabels, ElementTypeMatch } from \"../../chief\";\nimport { AddonProps } from \"../../addon\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\n\nconst TYPE: ElementTypeMatch = \"paragraph\";\n\nexport function ParagraphAddon({\n  showHint = true,\n  showPlaceholder = true,\n  labels\n}: {\n  showHint?: boolean;\n  showPlaceholder?: boolean;\n} & AddonProps) {\n  const [getLabel] = useLabels(labels);\n  useRenderElement(\n    {\n      typeMatch: TYPE,\n      renderElement: props => (\n        <ParagraphElement\n          hint={\n            showHint\n              ? getLabel({\n                  key: \"elements.paragraph.hint\",\n                  defaultLabel: \"Click to start typing\"\n                })\n              : undefined\n          }\n          placeholder={\n            showPlaceholder\n              ? getLabel({\n                  key: \"elements.paragraph.placeholder\",\n                  defaultLabel: \"Text\"\n                })\n              : undefined\n          }\n          {...props}\n        ></ParagraphElement>\n      )\n    },\n    [getLabel]\n  );\n  return null;\n}\n\nconst ParagraphPresenter: iPresenter = {\n  element: {\n    typeMatch: TYPE,\n    renderElement: props => <p>{props.children}</p>\n  }\n};\n\nParagraphAddon.Presenter = ParagraphPresenter;\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { renderLeaf } from \"../../leaf-renderer\";\nimport { useRenderLeaf } from \"../../chief/hooks/use-render-leaf\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { useLabels } from \"../../chief/hooks/use-labels\";\nimport { MarkBtn, toggleFormat } from \"../../mark-button\";\nimport { shortcutText } from \"../../shortcut\";\nimport { Control } from \"../../control\";\nimport { ReactEditor } from \"slate-react\";\nimport { InjectedRenderLeaf } from \"../../chief\";\nimport { iPresenter } from \"../../chief/chief-presentation\";\n\nconst shortcut = \"mod+b\";\n\nconst action = (editor: ReactEditor) => toggleFormat(editor, \"bold\");\n\nexport const boldControl: Control = {\n  category: \"marks\",\n  Component: () => {\n    return (\n      <MarkBtn\n        tooltip={{\n          label: {\n            key: \"marks.bold\",\n            defaultLabel: \"Bold\"\n          },\n          shortcut: shortcutText(shortcut)\n        }}\n        markType=\"bold\"\n      >\n        B\n      </MarkBtn>\n    );\n  }\n};\n\nconst _renderLeaf: InjectedRenderLeaf = {\n  renderLeaf: props => renderLeaf(props, \"bold\", \"strong\")\n};\n\nexport function BoldAddon(props: AddonProps) {\n  // useAddonAction(\"bold\", action);\n\n  // const boldToggle = useAddonAction(\"bold\");\n\n  useLabels(props.labels);\n  useRenderLeaf(_renderLeaf);\n  useOnKeyDown({\n    pattern: shortcut,\n    handler: (event, editor) => {\n      event.preventDefault();\n      action(editor);\n      return true;\n    }\n  });\n  return null;\n}\n\nconst Presenter: iPresenter = {\n  leaf: _renderLeaf\n};\n\nBoldAddon.Control = boldControl;\n\nBoldAddon.Presenter = Presenter;\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst HiddenFileInput = styled.input.attrs({\n  type: \"file\"\n})`\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute !important;\n  white-space: nowrap;\n  width: 1px;\n`;\n\nexport const FileUpload = React.forwardRef<\n  HTMLInputElement,\n  Omit<React.InputHTMLAttributes<HTMLInputElement>, \"type\" | \"id\">\n>((props, ref) => <HiddenFileInput ref={ref} {...props} />);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isPresent(t) {\n    return t !== undefined && t !== null;\n}\nexports.isPresent = isPresent;\nfunction isDefined(t) {\n    return t !== undefined;\n}\nexports.isDefined = isDefined;\nfunction isFilled(t) {\n    return t !== null;\n}\nexports.isFilled = isFilled;\n//# sourceMappingURL=index.js.map","import React, { Fragment, ReactNode } from \"react\";\n\nexport const Show = (props: {\n  when: any | undefined | null;\n  children: ReactNode;\n}) => {\n  const { when, children } = props;\n  if (!Boolean(when)) {\n    return null;\n  }\n  return <Fragment>{children}</Fragment>;\n};\n","import React, { useState } from \"react\";\nimport { RenderElementProps } from \"slate-react\";\nimport { useFocused } from \"./Focused\";\nimport { Show } from \"./show\";\nimport { useChief } from \"./chief/hooks/use-chief\";\n\nexport function ElementWrapper(\n  props: RenderElementProps & {\n    attentionChildren?: React.ReactNode;\n    style?: React.CSSProperties;\n  }\n) {\n  const {\n    children,\n    element,\n    attentionChildren,\n    style,\n    attributes,\n    ...otherProps\n  } = props;\n  const { isFocusedWithin } = useFocused(element);\n  const [inside, setInside] = useState(false);\n  const { readOnly } = useChief();\n  const handleEnter = () => {\n    !readOnly && setInside(true);\n  };\n  const handleLeave = () => {\n    setInside(false);\n  };\n  return (\n    <div\n      data-slate-zero-width=\"z\"\n      onMouseEnter={handleEnter}\n      onMouseLeave={handleLeave}\n      style={{ position: \"relative\" }}\n      {...otherProps}\n    >\n      <Show when={!readOnly && (isFocusedWithin || inside)}>\n        <div style={{ position: \"absolute\", zIndex: 2, ...style }}>\n          {attentionChildren}\n        </div>\n      </Show>\n      {children}\n    </div>\n  );\n}\n","import { Node, Path } from \"slate\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { useState, useEffect } from \"react\";\n\nexport const useFocused = (node?: Node) => {\n  const editor = useSlate();\n  const { selection } = editor;\n  const [focus, setFocus] = useState({\n    isFocused: false,\n    isFocusedWithin: false\n  });\n  useEffect(() => {\n    if (!node) {\n      return;\n    }\n    const path = ReactEditor.findPath(editor, node);\n    let isFocused = false;\n    let isFocusedWithin = false;\n    if (selection) {\n      const { focus } = selection;\n      isFocusedWithin = Path.isDescendant(focus.path, path);\n      isFocused = Path.equals(focus.path, path);\n    }\n    setFocus({ isFocused, isFocusedWithin });\n  }, [node, selection]);\n\n  return focus;\n};\n","import styled from \"styled-components\";\nexport const ToolsWrapper = styled.div`\n  display: flex;\n`;\n","import styled from \"styled-components\";\nimport { StyledToolBase } from \"../StyledToolBox\";\nimport { ButtonBase } from \"./button-base\";\n\nexport const StyledFocusToolBtn = styled(ButtonBase)`\n  background-color: rgba(47, 47, 47, 0.67);\n  &:hover {\n    background-color: rgba(67, 67, 67, 0.67);\n  }\n  color: white;\n  border: none;\n  &:first-child {\n    border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px;\n  }\n  &:last-child {\n    border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px;\n  }\n  padding: 4px 8px;\n  margin: 0 1px;\n`;\n\nexport const StyledFocusToolbar = styled(StyledToolBase)`\n  background-color: transparent;\n`;\n","import React from \"react\";\nimport { RenderElementProps } from \"slate-react\";\nimport { ElementWrapper } from \"../element-wrapper\";\nimport { ToolsWrapper } from \"../ToolsWrapper\";\nimport { StyledFocusToolbar } from \"./StyledFocusToolbar\";\n\nexport function WithAttentionToolbar(\n  props: RenderElementProps & {\n    children: React.ReactNode;\n    btns: React.ReactNode;\n  }\n) {\n  const { btns, children, ...renderElementProps } = props;\n  return (\n    <ElementWrapper\n      {...renderElementProps}\n      attentionChildren={\n        <StyledFocusToolbar>\n          <ToolsWrapper>{btns}</ToolsWrapper>\n        </StyledFocusToolbar>\n      }\n      style={{ right: 0, marginTop: 5, marginRight: 5 }}\n    >\n      {children}\n    </ElementWrapper>\n  );\n}\n","import styled from \"styled-components\";\nimport { ButtonBase } from \"./button-base\";\n\nexport const Button = styled(ButtonBase)`\n  background-color: ${props => props.theme.colors.primary};\n  :hover  {\n    filter: brightness(85%);\n  }\n  :active  {\n    filter: brightness(75%);\n  }\n  :disabled {\n    background-color: ${props => props.theme.colors.gray[400]};\n    color: ${props => props.theme.colors.gray[500]};\n  }\n  color: white;\n  border-radius: 0;\n  border: none;\n  padding: 4px 8px;\n`;\n","import React, { useState, useCallback, useEffect } from \"react\";\nimport { Transforms } from \"slate\";\nimport { useFocused, useSelected, ReactEditor, useSlate } from \"slate-react\";\nimport { WithAttentionToolbar } from \"../../ui/WithAttentionToolbar\";\nimport { Input, InputWrapper } from \"../../InputWrapper\";\nimport isUrl from \"is-url\";\nimport { ImageElement } from \"./index\";\nimport { Button } from \"../../ui/button\";\nimport styled from \"styled-components\";\nimport { ToolBtnPopup } from \"../../ToolBtnPopup\";\nimport { StyledToolBox } from \"../../StyledToolBox\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { StyledFocusToolBtn } from \"../../ui/StyledFocusToolbar\";\nimport { ChiefRenderElementProps } from \"../../chief/chief\";\nimport { UiWrap } from \"../../ui/ui-wrap\";\nimport ReactResizeDetector from \"react-resize-detector/lib/\";\nimport { useChief } from \"../../chief/hooks/use-chief\";\n\nexport const ImageBlock = (\n  props: ChiefRenderElementProps<ImageElement> & {\n    onOpenFileRequest?: () => void;\n    onRemoved?: (url: string | null) => void;\n  }\n) => {\n  const focused = useFocused();\n  const selected = useSelected();\n  const editor = useSlate();\n  const { readOnly } = useChief();\n  const { onOpenFileRequest, onRemoved, ...renderElementProps } = props;\n  const { element, children, attributes } = renderElementProps;\n\n  const [embedUrl, setEmbedUrl] = useState(element.url || \"\");\n  const [isReplacing, setIsReplacing] = useState(false);\n\n  const handleSubmitEmbed = useCallback(\n    (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault();\n      if (embedUrl.length > 0) {\n        Transforms.setNodes(\n          editor,\n          {\n            url: embedUrl,\n            align: \"center\"\n          },\n          {\n            at: ReactEditor.findPath(editor, element)\n          }\n        );\n        if (isReplacing) {\n          setIsReplacing(false);\n        }\n      }\n    },\n    [embedUrl, isReplacing]\n  );\n\n  useEffect(() => {\n    if (element.url && isReplacing) {\n      setIsReplacing(false);\n    }\n  }, [element.url]);\n\n  const handleDelete = useCallback(() => {\n    onRemoved && onRemoved(element.url);\n    Transforms.delete(editor, { at: ReactEditor.findPath(editor, element) });\n  }, [element]);\n\n  const handleUpload = useCallback(() => {\n    onOpenFileRequest && onOpenFileRequest();\n  }, [onOpenFileRequest]);\n\n  const handleResize = useCallback((w, h) => {\n    Transforms.setNodes(\n      editor,\n      {\n        width: w,\n        height: h\n      },\n      {\n        at: ReactEditor.findPath(editor, element)\n      }\n    );\n  }, []);\n\n  const align = useCallback((align: ImageElement[\"align\"]) => {\n    Transforms.setNodes(\n      editor,\n      {\n        align\n      },\n      {\n        at: ReactEditor.findPath(editor, element)\n      }\n    );\n  }, []);\n\n  const toggleReplace = useCallback(() => {\n    setIsReplacing(!isReplacing);\n  }, [isReplacing]);\n\n  const handleClick = () => {\n    Transforms.select(editor, ReactEditor.findPath(editor, element));\n  };\n\n  let imageHandler = null;\n\n  if (!isReplacing && element.url) {\n    const src = element.url || \"\";\n    imageHandler = (\n      <WithAttentionToolbar\n        {...renderElementProps}\n        btns={\n          <React.Fragment>\n            <StyledFocusToolBtn onMouseDown={handleDelete}>\n              Delete\n            </StyledFocusToolBtn>\n            <ToolBtnPopup\n              renderContent={() => (\n                <StyledToolBox>\n                  {/* <ToolbarBtn>Copy address</ToolbarBtn> */}\n                  {/* <ToolbarBtn>Resize</ToolbarBtn> */}\n                  <ToolbarBtn onMouseDown={toggleReplace}>Replace</ToolbarBtn>\n                  <ToolbarBtn onMouseDown={() => align(\"left\")}>\n                    Align left\n                  </ToolbarBtn>\n                  <ToolbarBtn onMouseDown={() => align(\"center\")}>\n                    Align center\n                  </ToolbarBtn>\n                  <ToolbarBtn onMouseDown={() => align(\"right\")}>\n                    Align right\n                  </ToolbarBtn>\n                </StyledToolBox>\n              )}\n              renderToolBtn={tprops => (\n                <StyledFocusToolBtn {...tprops}>...</StyledFocusToolBtn>\n              )}\n            ></ToolBtnPopup>\n          </React.Fragment>\n        }\n      >\n        <div\n          style={{\n            position: \"relative\",\n            height: element.height,\n            display: \"flex\",\n            justifyContent:\n              props.element.align === \"center\"\n                ? \"center\"\n                : props.element.align === \"left\"\n                ? \"flex-start\"\n                : \"flex-end\"\n          }}\n          contentEditable={false}\n          onClick={handleClick}\n        >\n          <ReactResizeDetector\n            onResize={(w: number, h: number) => handleResize(w, h)}\n          >\n            <div\n              style={{\n                resize: readOnly ? \"none\" : \"both\",\n                overflow: \"auto\",\n                width: element.width,\n                height: element.height\n              }}\n            >\n              <img\n                draggable={false}\n                style={{\n                  objectFit: \"fill\",\n                  width: \"100%\",\n                  height: \"100%\",\n                  display: \"block\"\n                }}\n                alt={element.caption}\n                src={src}\n              />\n            </div>\n          </ReactResizeDetector>\n        </div>\n        {children}\n      </WithAttentionToolbar>\n    );\n  } else {\n    imageHandler = (\n      <WithAttentionToolbar\n        {...renderElementProps}\n        btns={\n          <React.Fragment>\n            <StyledFocusToolBtn onMouseDown={handleDelete}>\n              Delete\n            </StyledFocusToolBtn>\n            {isReplacing && (\n              <StyledFocusToolBtn onMouseDown={toggleReplace}>\n                Cancel\n              </StyledFocusToolBtn>\n            )}\n          </React.Fragment>\n        }\n      >\n        <div contentEditable={false}>\n          <StyledImageEmptyContainer>\n            <h2>Insert image</h2>\n            <Button onMouseDown={handleUpload}>Upload</Button>\n            <p>Or paste a link</p>\n            <form onSubmit={handleSubmitEmbed} data-slate-editor>\n              <InputWrapper style={{ width: \"50%\" }}>\n                <Input\n                  value={embedUrl}\n                  onChange={e => setEmbedUrl(e.target.value)}\n                  placeholder=\"Paste link\"\n                ></Input>\n              </InputWrapper>\n              <br />\n              <Button disabled={embedUrl.length === 0 || !isUrl(embedUrl)}>\n                Embed\n              </Button>\n            </form>\n            {children}\n          </StyledImageEmptyContainer>\n        </div>\n      </WithAttentionToolbar>\n    );\n  }\n\n  return (\n    <div\n      style={{\n        outline: focused && selected ? \"1px solid rgb(46, 170, 220)\" : \"none\"\n      }}\n      {...attributes}\n      contentEditable={false}\n    >\n      {imageHandler}\n    </div>\n  );\n};\n\nexport const StyledImageEmptyContainer = styled(UiWrap)`\n  background-color: ${props => props.theme.colors.gray[300]};\n  padding: 8px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  form {\n    width: 70%;\n    display: flex;\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n  }\n  h2,\n  p {\n    color: ${props => props.theme.colors.gray[600]};\n    user-select: none;\n  }\n`;\n","import {} from \"./image-element\";\nimport React, { useRef, useEffect } from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { Element, Editor, Transforms } from \"slate\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { isNodeActive, getNodeFromSelection, findNodes } from \"../../utils\";\nimport { RichEditor } from \"../../chief/editor\";\nimport { FileUpload } from \"../../FileUpload\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { ChiefElement, isChiefElement } from \"../../chief/chief\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { usePlugin } from \"../../chief/hooks/use-plugin\";\nimport { isDefined, isFilled } from \"ts-is-present\";\nimport { HistoryEditor } from \"slate-history\";\nimport isUrl from \"is-url\";\nimport { ImageExtensions } from \"./ImageExtensions\";\nimport { ImageBlock } from \"./image-element\";\nimport { Control } from \"../../control\";\nimport { iPresenter } from \"../../chief\";\n\nexport interface ImageElement extends ChiefElement {\n  type: \"image\";\n  url: string | null;\n  caption?: string;\n  previewId?: number;\n  width: number;\n  height: number;\n  align: \"left\" | \"center\" | \"right\";\n}\n\nexport function isImageElement(element: unknown): element is ImageElement {\n  return isChiefElement(element) && element.type === \"image\";\n}\n\nexport const imageBlockControls: Control[] = [\n  {\n    category: \"image\",\n    render: editor => (\n      <ToolbarBtn\n        isActive={isNodeActive(editor, \"image\")}\n        onClick={() => {\n          RichEditor.insertBlock(editor, \"image\");\n          ReactEditor.focus(editor);\n        }}\n      >\n        Image\n      </ToolbarBtn>\n    )\n  }\n];\n\nexport const isImageUrl = (url: string, extensions = ImageExtensions) => {\n  if (!url) return false;\n  if (!isUrl(url)) return false;\n  const ext = new URL(url).pathname.split(\".\").pop() as string;\n  return extensions.includes(ext);\n};\n\nconst insertImage = (editor: ReactEditor, url: string) => {\n  const image = { type: \"image\", url, children: [{ text: \"\" }] };\n  Transforms.insertNodes(editor, image);\n};\n\nfunction getAllImageNodes(editor: Editor) {\n  const [...images] = findNodes(editor, n => n.type === \"image\");\n  return images.map(([node]) => node) as ImageElement[];\n}\n\nconst Presenter: iPresenter<ImageElement> = {\n  element: {\n    typeMatch: \"image\",\n    renderElement: props => (\n      <div\n        style={{\n          display: \"flex\",\n          justifyContent:\n            props.element.align === \"center\"\n              ? \"center\"\n              : props.element.align === \"left\"\n              ? \"flex-start\"\n              : \"flex-end\"\n        }}\n      >\n        <img\n          style={{\n            objectFit: \"fill\",\n            width: props.element.width,\n            height: props.element.height,\n            display: \"block\"\n          }}\n          alt={props.element.caption}\n          src={props.element?.url ? props.element.url : \"\"}\n        />\n      </div>\n    )\n  }\n};\n\nexport function ImageAddon(\n  props: AddonProps & {\n    onUploadRequest?: (files: globalThis.FileList | null) => Promise<string>;\n    onRemoved?: (url: string | null) => void;\n    onChange?: (images: ImageElement[]) => void;\n  }\n) {\n  const editor = useSlate();\n  const fileRef = useRef<HTMLInputElement>(null);\n\n  usePlugin({\n    isVoid: isVoid => element =>\n      isImageElement(element) && element.type === \"image\"\n        ? true\n        : isVoid(element),\n    insertData: (insertData, editor) => data => {\n      const { files } = data;\n      if (files && files.length > 0) {\n        for (const file of Array.from(files)) {\n          const reader = new FileReader();\n          const [mime] = file.type.split(\"/\");\n          if (mime === \"image\") {\n            reader.addEventListener(\"load\", () => {\n              const url = reader.result as string;\n              insertImage(editor, url);\n            });\n            reader.readAsDataURL(file);\n          }\n        }\n      } else {\n        insertData(data);\n      }\n    }\n  });\n\n  const onPreview = (dataUrl: FileReader[\"result\"]) => {\n    if (typeof dataUrl === \"string\") {\n      if (HistoryEditor.isHistoryEditor(editor)) {\n        HistoryEditor.withoutSaving(editor, () => {\n          Transforms.setNodes(editor, {\n            url: dataUrl\n          });\n        });\n      }\n    }\n  };\n\n  const handleFile = async (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (!editor.selection) {\n      return;\n    }\n    const imageRef = Editor.rangeRef(editor, editor.selection);\n    const onUploadedSuccess = (url: string) => {\n      if (!imageRef.current) return;\n      const node = getNodeFromSelection(editor, imageRef.current);\n      if (node && isImageElement(node)) {\n        Transforms.setNodes(\n          editor,\n          {\n            url,\n            align: \"center\"\n          },\n          { at: imageRef.current! }\n        );\n        imageRef.unref();\n      }\n    };\n\n    const onUploadedFailed = () => {\n      if (!imageRef.current) return;\n      Transforms.setNodes(\n        editor,\n        {\n          // url: null,\n          error: \"failedupload\"\n        },\n        { at: imageRef.current }\n      );\n      imageRef.unref();\n    };\n\n    const files = e.target.files;\n    if (!files) {\n      return;\n    }\n    if (files.length > 0) {\n      const file = files[0];\n      const reader = new FileReader();\n      reader.addEventListener(\"load\", () => onPreview(reader.result));\n      reader.readAsDataURL(file);\n      if (props.onUploadRequest) {\n        try {\n          const url = await props.onUploadRequest(files);\n          onUploadedSuccess(url);\n        } catch (err) {\n          onUploadedFailed();\n        }\n      }\n    }\n  };\n\n  let imageUrls: ImageElement[] = [];\n  if (props.onChange) {\n    imageUrls = getAllImageNodes(editor)\n      .map(it => it)\n      .filter(isDefined)\n      .filter(isFilled);\n  }\n\n  useEffect(() => {\n    props.onChange && props.onChange(imageUrls);\n  }, [JSON.stringify(imageUrls), props.onChange]);\n\n  useRenderElement<ImageElement>(\n    {\n      typeMatch: \"image\",\n      renderElement: renderElementProps => (\n        <ImageBlock\n          onOpenFileRequest={() => fileRef.current && fileRef.current.click()}\n          onRemoved={props.onRemoved}\n          {...renderElementProps}\n        />\n      )\n    },\n    [props.onRemoved]\n  );\n\n  return (\n    <FileUpload\n      accept={\"image/*\"}\n      ref={fileRef}\n      onChange={handleFile}\n      multiple={false}\n    />\n  );\n}\n\nImageAddon.Presenter = Presenter;\n","import { Editor, Transforms, Node } from \"slate\";\n\nexport const toggleElement = (editor: Editor, type: string) => {\n  const isActive = isElementActive(editor, type);\n  const { selection } = editor;\n  if (!selection) {\n    return;\n  }\n  Transforms.setNodes(editor, {\n    type: isActive ? \"paragraph\" : type,\n    autoFocus: true,\n    at: selection.focus\n  });\n};\n\nexport const isElementActive = (editor: Editor, type: string) => {\n  const { selection } = editor;\n  if (!selection) {\n    return false;\n  }\n  const [match] = Editor.nodes(editor, {\n    at: selection,\n    match: n => n.type === type\n  });\n  return !!match;\n};\n\nexport const isElementEmpty = (editor: Editor) => {\n  const { selection } = editor;\n\n  if (selection) {\n    const [node] = Editor.parent(editor, selection.focus);\n    return Node.string(node).length === 0;\n  }\n  return false;\n};\n","import { ReactEditor } from \"slate-react\";\nimport { isElementActive } from \"../../element-utils\";\nimport { Transforms, Editor } from \"slate\";\nimport { TYPE_LIST_ITEM } from \".\";\n\nexport const toggleList = (editor: ReactEditor, type: string) => {\n  const isActive = isElementActive(editor, type);\n  Transforms.unwrapNodes(editor, {\n    match: n => n.type === type,\n    split: true\n  });\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.setNodes(editor, {\n      type: isActive ? \"paragraph\" : TYPE_LIST_ITEM\n    });\n\n    if (!isActive) {\n      const list = {\n        type,\n        children: []\n      };\n      Transforms.wrapNodes(editor, list);\n    }\n  });\n};\n","import React from \"react\";\nimport { RenderElementProps } from \"slate-react\";\n\nexport const renderElement = (\n  props: RenderElementProps,\n  elementType: string,\n  reactType: Parameters<typeof React.createElement>[\"0\"],\n  addionalProps?: any\n) => {\n  const { children, attributes, element } = props;\n  if (element.type === elementType) {\n    return React.createElement(\n      reactType,\n      { ...attributes, ...addionalProps },\n      children\n    );\n  }\n  return undefined;\n};\n","import { ReactEditor, useSlate } from \"slate-react\";\nimport { Point, Editor, Range, Node } from \"slate\";\nimport { ChiefElement, isChiefElement } from \"./chief\";\n\ninterface ChiefState {\n  editor: ReactEditor;\n  element?: ChiefElement | Editor | undefined;\n  elementType?: string;\n  point?: Point;\n  isElementEmpty: boolean;\n  selection?: Range | null;\n  isSelectionCollapsed: boolean;\n  isSelectionExpanded: boolean;\n}\n\nexport function getState(editor: ReactEditor): ChiefState {\n  const { selection } = editor;\n  const point = selection ? selection.focus : undefined;\n  const [element] = point ? Editor.parent(editor, point) : [];\n\n  let isSelectionExpanded = false;\n  let isSelectionCollapsed = true;\n  if (selection) {\n    isSelectionExpanded = Range.isExpanded(selection);\n    isSelectionCollapsed = Range.isCollapsed(selection);\n  }\n\n  let isElementEmpty = true;\n\n  if (element) {\n    isElementEmpty = Node.string(element).length == 0;\n  }\n  let elementType: string | undefined = undefined;\n\n  if (element && isChiefElement(element)) {\n    elementType = element.type;\n  }\n\n  return {\n    editor,\n    // TODO:: THIS\n    // @ts-ignore\n    element,\n    elementType,\n    point,\n    selection,\n    isElementEmpty,\n    isSelectionExpanded,\n    isSelectionCollapsed\n  };\n}\n","import React from \"react\";\nimport { toggleList } from \"./transforms\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { isNodeActive } from \"../../utils\";\nimport { Control } from \"../../control\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\nimport { TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST } from \"./index\";\n\nexport const listControl: Control = {\n  category: \"lists\",\n  Component: () => {\n    const editor = useSlate();\n    return (\n      <React.Fragment>\n        <ToolbarBtn\n          isActive={isNodeActive(editor, TYPE_ORDERED_LIST)}\n          onClick={() => {\n            toggleList(editor, TYPE_ORDERED_LIST);\n            ReactEditor.focus(editor);\n          }}\n        >\n          OL\n        </ToolbarBtn>\n        <ToolbarBtn\n          isActive={isNodeActive(editor, TYPE_UNORDERED_LIST)}\n          onClick={() => {\n            toggleList(editor, TYPE_UNORDERED_LIST);\n            ReactEditor.focus(editor);\n          }}\n        >\n          UL\n        </ToolbarBtn>\n      </React.Fragment>\n    );\n  }\n};\n","import { toggleList } from \"./transforms\";\nimport { ChiefElement, InjectedRenderElement } from \"../../chief/chief\";\nimport { useRenderElement } from \"../../chief/hooks/use-render-element\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\nimport { usePlugin } from \"../../chief/hooks/use-plugin\";\nimport { renderElement } from \"../../element-renderer\";\nimport { Editor, Transforms, Element, Range } from \"slate\";\nimport { ReactEditor } from \"slate-react\";\nimport { isElementEmpty } from \"../../element-utils\";\nimport { getState } from \"../../chief/chief-state\";\nimport { getAncestor, getActiveNode } from \"../../utils\";\nimport { AddonProps } from \"../../addon\";\nimport { listControl } from \"./controls\";\nimport styled, { css } from \"styled-components\";\nimport { useDecoration } from \"../../chief/hooks/use-decoration\";\nimport { iPresenter } from \"../../chief\";\n\nexport const TYPE_LIST_ITEM = \"list-item\";\nexport const TYPE_UNORDERED_LIST = \"unordered-list\";\nexport const TYPE_ORDERED_LIST = \"ordered-list\";\nexport const LIST_TYPES = [\n  TYPE_LIST_ITEM,\n  TYPE_UNORDERED_LIST,\n  TYPE_ORDERED_LIST\n];\n\ntype ListElement = {} & ChiefElement;\n\nconst Ul = styled.ul`\n  margin: 0;\n  padding-inline-start: 25px;\n  ul ul ul ul,\n  ul {\n    list-style: square outside none;\n  }\n\n  ul ul ul ul ul,\n  ul ul {\n    list-style: circle outside none;\n  }\n\n  ul ul ul ul ul ul,\n  ul ul ul {\n    list-style: disc outside none;\n  }\n`;\nconst Ol = styled.ol`\n  margin: 0;\n  padding-inline-start: 25px;\n  ol ol ol ol,\n  ol {\n    list-style: decimal outside none;\n  }\n  ol ol ol ol ol,\n  ol ol {\n    list-style: lower-latin outside none;\n  }\n  ol ol ol ol ol ol,\n  ol ol ol {\n    list-style: lower-roman outside none;\n  }\n`;\n\nconst Li = styled.li``;\n\nconst _renderElement: InjectedRenderElement = {\n  typeMatch: LIST_TYPES,\n  renderElement: props => {\n    switch (props.element.type) {\n      case TYPE_UNORDERED_LIST:\n        return renderElement(props, props.element.type, Ul);\n      case TYPE_ORDERED_LIST:\n        return renderElement(props, props.element.type, Ol);\n      default:\n        return renderElement(props, TYPE_LIST_ITEM, Li);\n    }\n  }\n};\n\nconst Presenter: iPresenter = {\n  element: _renderElement\n};\n\nexport function ListsAddon(props: AddonProps) {\n  usePlugin({\n    normalizeNode: (normalizeNode, editor) => ([node, path]) => {\n      if (node.type === TYPE_LIST_ITEM) {\n        const [parent] = Editor.parent(editor, path);\n        if (\n          parent &&\n          ![TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST].includes(\n            parent.type as string\n          )\n        ) {\n          Transforms.setNodes(editor, { type: \"paragraph\" }, { at: path });\n        }\n      }\n      return normalizeNode([node, path]);\n    }\n  });\n\n  useRenderElement<ListElement>(_renderElement);\n\n  useOnKeyDown({\n    pattern: \"enter\",\n    handler: (e, editor) => {\n      const { elementType, element } = getState(editor);\n      if (elementType !== TYPE_LIST_ITEM) {\n        return false;\n      }\n      let ancestor = getAncestor(editor, element as Element, 1);\n\n      if (\n        !ancestor ||\n        ![TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST].includes(\n          ancestor!.type as string\n        )\n      ) {\n        return false;\n      }\n      e.preventDefault();\n      if (!isElementEmpty(editor)) {\n        Editor.withoutNormalizing(editor, () => {\n          Transforms.insertNodes(editor, {\n            type: TYPE_LIST_ITEM,\n            children: [{ text: \"\" }]\n          });\n        });\n      } else {\n        const active = getActiveNode(editor);\n        if (!active) {\n          return false;\n        }\n        const list = getAncestor(editor, active, 1) as Element;\n        const listParent = getAncestor(editor, active, 2);\n\n        if (listParent && listParent.children[0].type === TYPE_LIST_ITEM) {\n          //2. If nested then unwrap and move left\n          Transforms.unwrapNodes(editor, {\n            match: n => n.type === list.type,\n            split: true\n          });\n        } else {\n          //3. At top level so cannot unwrap, insert new paragraph and break from list\n          toggleList(editor, list.type as string);\n        }\n      }\n\n      return true;\n    }\n  });\n  useOnKeyDown({\n    pattern: \"tab\",\n    handler: (e, editor) => {\n      const { elementType, element } = getState(editor);\n      if (!element || elementType !== TYPE_LIST_ITEM) {\n        return false;\n      }\n\n      let ancestor = getAncestor(editor, element, 1);\n      if (\n        !ancestor ||\n        ![TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST].includes(\n          ancestor!.type as string\n        )\n      ) {\n        return false;\n      }\n\n      if (ancestor.children.length > 1) {\n        e.preventDefault();\n        const index = ancestor?.children.indexOf(element) - 1;\n        if (ancestor.children[index].type !== TYPE_LIST_ITEM) {\n          // 3a. tab = move right. If the node above is a list then append to it.\n          const otherList = ancestor.children[index] as Element;\n          const destination = ReactEditor.findPath(\n            editor,\n            otherList.children[otherList.children.length - 1]\n          );\n          destination[destination.length - 1]++;\n          Transforms.moveNodes(editor, {\n            to: destination\n          });\n        } else {\n          // 3b. otherwise, wrap the item in a new list and nest in parent\n          Transforms.wrapNodes(editor, { type: ancestor.type, children: [] });\n        }\n        return true;\n      }\n      return false;\n    }\n  });\n  useOnKeyDown({\n    pattern: \"shift+tab\",\n    handler: (e, editor) => {\n      const { elementType, element } = getState(editor);\n      if (!element || elementType !== TYPE_LIST_ITEM) {\n        return false;\n      }\n\n      let ancestor = getAncestor(editor, element, 1);\n      if (\n        !ancestor ||\n        ![TYPE_ORDERED_LIST, TYPE_UNORDERED_LIST].includes(\n          ancestor!.type as string\n        )\n      ) {\n        return false;\n      }\n\n      if (e.shiftKey) {\n        let ancestor = getAncestor(editor, element, 2);\n        // 1. tab+shift = move left to grandparent list if nested\n        if (ancestor?.children.find(child => child.type === TYPE_LIST_ITEM)) {\n          Transforms.liftNodes(editor);\n        } else {\n          const options = {\n            at: ReactEditor.findPath(editor, element)\n          };\n          // 2. tab+shift = unwrap and move to below parent if no grandparent list\n          if (element?.children.length == 1) {\n            Transforms.setNodes(editor, { type: \"paragraph\" }, options);\n          } else {\n            Transforms.unwrapNodes(editor, options);\n          }\n        }\n        e.preventDefault();\n        return true;\n      }\n      return false;\n    }\n  });\n  return null;\n}\n\nListsAddon.Control = listControl;\nListsAddon.Presenter = Presenter;\n\n","import { AddonProps } from \"../../addon\";\nimport { useOnKeyDown } from \"../../chief/hooks/use-on-key-down\";\n\nexport function BlockTabAddon(props: AddonProps) {\n  useOnKeyDown({\n    pattern: \"tab\",\n    priority: \"low\",\n    handler: e => {\n      e.preventDefault();\n      return true;\n    }\n  });\n  return null;\n}\n","import styled from \"styled-components\";\nexport const ToolDivider = styled.div`\n  width: 1px;\n  background-color: #eaeaea;\n  ${props =>\n    props.theme.preferDarkOption &&\n    `\n@media (prefers-color-scheme: dark) {\n  background-color: #737373;\n  }`}\n`;\n","import React from \"react\";\nimport groupBy from \"lodash/groupBy\";\nimport { ReactEditor, useSlate } from \"slate-react\";\nimport { StyledToolbarBtn } from \"../../ui/styled-toolbar-btn\";\nimport { StyledToolBox } from \"../../StyledToolBox\";\nimport { ToolDivider } from \"../../ToolDivider\";\nimport { ToolsWrapper } from \"../../ToolsWrapper\";\nimport { isNodeActive } from \"../../utils\";\nimport { Control } from \"../../control\";\nimport { RichEditor } from \"../../chief/editor\";\nimport { ToolbarBtn } from \"../../ToolbarBtn\";\n\nexport function BlockInsertControls(props: { controls: Control[] }) {\n  const editor = useSlate();\n  const controls = props.controls;\n  if (controls.length > 0) {\n    const grouped = groupBy(controls, \"category\");\n    return (\n      <StyledToolBox>\n        <ToolsWrapper>\n          {Object.entries(grouped).map(([k, groupedControls]) => (\n            <React.Fragment>\n              {groupedControls.map((control, i) => {\n                if (control.Component) {\n                  return <control.Component key={i} />;\n                }\n                const renderButton = control.render;\n                return typeof renderButton === \"function\"\n                  ? renderButton(editor)\n                  : renderButton;\n              })}\n              <ToolDivider />\n            </React.Fragment>\n          ))}\n          <ToolDivider />\n          <ToolbarBtn\n            isActive={isNodeActive(editor, \"paragraph\")}\n            onMouseDown={() => {\n              RichEditor.insertBlock(editor, \"paragraph\");\n              ReactEditor.focus(editor);\n            }}\n          >\n            Text\n          </ToolbarBtn>\n        </ToolsWrapper>\n      </StyledToolBox>\n    );\n  }\n  return null;\n}\n","import {\n  isBlockEmpty,\n  getActiveNode,\n  useOnClickOutside,\n  getAncestor\n} from \"../../utils\";\nimport React, { useState, useCallback, useEffect, useRef } from \"react\";\nimport { useSlate, ReactEditor } from \"slate-react\";\nimport { Node, Editor, Path, Transforms } from \"slate\";\nimport { Manager, Reference, Popper } from \"react-popper\";\nimport styled from \"styled-components\";\nimport { ButtonBase } from \"../../ui/button-base\";\n\nexport const BlockInsertBtn = styled(ButtonBase)`\n  user-select: none;\n  border: none;\n  background: transparent;\n  display: block;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #ccc;\n  border-radius: ${25 / 2}px;\n  &:before {\n    content: \"+\";\n    font-family: Arial, Helvetica, sans-serif;\n    font-weight: normal;\n    font-size: 28px;\n    color: #ccc;\n    position: absolute;\n    top: -3px;\n    left: 4px;\n    padding: 0;\n    margin: 0;\n  }\n  &:hover {\n    &:before {\n      color: #ddd;\n    }\n  }\n  &:active {\n    &:before {\n      color: #eee;\n    }\n  }\n`;\n\nfunction useHoveredNode(editor: ReactEditor) {\n  const [node, setNode] = useState<{ node: Node; path: Path } | null>(null);\n  useEffect(() => {\n    try {\n      const [rootNode] = Editor.node(editor, {\n        anchor: Editor.start(editor, []),\n        focus: Editor.end(editor, [])\n      });\n      if (rootNode && Node.isNode(rootNode)) {\n        const firstDOMPoint = ReactEditor.toDOMNode(editor, rootNode);\n        firstDOMPoint.addEventListener(\"mousemove\", e => {\n          if (ReactEditor.hasDOMNode(editor, e.target as globalThis.Node)) {\n            const node = ReactEditor.toSlateNode(\n              editor,\n              e.target as globalThis.Node\n            );\n            const path = ReactEditor.findPath(editor, node);\n            setNode({ node, path });\n          } else {\n            setNode(null);\n          }\n        });\n      }\n    } catch (err) {\n      setNode(null);\n    }\n  }, [editor]);\n  return node;\n}\n\nexport function BlockInsert(props: { children?: React.ReactNode }) {\n  const editor = useSlate();\n  const [coords, setCoords] = useState([-1000, -1000]);\n  const [showMenu, setShowMenu] = useState(false);\n  const toolboxRef = useRef<HTMLDivElement>(null);\n  useOnClickOutside(toolboxRef, () => {\n    setShowMenu(false);\n  });\n\n  const hoveredNode = useHoveredNode(editor);\n\n  const handleBlockInsert = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n      event.preventDefault();\n      event.stopPropagation();\n      if (!showMenu && hoveredNode) {\n        Transforms.select(editor, hoveredNode.path);\n      }\n      setShowMenu(!showMenu);\n      ReactEditor.focus(editor);\n    },\n    [showMenu, hoveredNode]\n  );\n\n  useEffect(() => {\n    if (hoveredNode?.node && !showMenu) {\n      try {\n        const [rootNode] = Editor.node(editor, {\n          anchor: Editor.start(editor, []),\n          focus: Editor.end(editor, [])\n        });\n        if (rootNode && Node.isNode(rootNode)) {\n          const firstDOMPoint = ReactEditor.toDOMNode(editor, rootNode);\n          const activeDOMNode = ReactEditor.toDOMNode(editor, hoveredNode.node);\n          const rect = activeDOMNode.getBoundingClientRect();\n          const top = rect.top + window.pageYOffset + rect.height / 2 - 25 / 2;\n          const left =\n            firstDOMPoint.getBoundingClientRect().left +\n            window.pageXOffset -\n            30;\n          setCoords([top, left]);\n        }\n      } catch (err) {}\n    }\n  }, [hoveredNode]);\n\n  if (\n    !hoveredNode ||\n    hoveredNode.path.length === 0 ||\n    Node.string(hoveredNode.node).length !== 0 ||\n    Editor.isVoid(editor, hoveredNode.node)\n  ) {\n    if (!showMenu) {\n      return null;\n    }\n  }\n  return (\n    <Manager>\n      <Reference>\n        {({ ref }) => (\n          <div\n            ref={ref}\n            style={{ position: \"absolute\", top: coords[0], left: coords[1] }}\n          >\n            <BlockInsertBtn onClick={handleBlockInsert} />\n          </div>\n        )}\n      </Reference>\n      {showMenu && (\n        <Popper\n          placement=\"bottom-end\"\n          modifiers={[\n            {\n              name: \"offset\",\n              options: {\n                offset: [25, 10]\n              }\n            }\n          ]}\n        >\n          {({ ref, style, placement, arrowProps }) => (\n            <div\n              ref={ref}\n              style={{ ...style, zIndex: 20 }}\n              data-placement={placement}\n              onMouseDown={e => {\n                if (!e.isDefaultPrevented()) {\n                  e.preventDefault();\n                  setShowMenu(false);\n                  ReactEditor.focus(editor);\n                  editor.selection &&\n                    Transforms.select(editor, editor.selection.focus);\n                }\n              }}\n            >\n              <div ref={toolboxRef}>{props.children}</div>\n              <div ref={arrowProps.ref} style={arrowProps.style} />\n            </div>\n          )}\n        </Popper>\n      )}\n    </Manager>\n  );\n}\n","import React from \"react\";\nimport groupBy from \"lodash/groupBy\";\nimport { Editor as SlateEditor } from \"slate\";\nimport { useSlate } from \"slate-react\";\nimport { StyledToolBox } from \"../../StyledToolBox\";\nimport { ToolDivider } from \"../../ToolDivider\";\nimport { ToolsWrapper } from \"../../ToolsWrapper\";\nimport { ChiefElement } from \"../../chief/chief\";\nimport { Control } from \"../../control\";\nimport { matchesType } from \"../../chief/utils/matches-type\";\n\nexport function HoverToolControls(props: { controls: Control[]; }) {\n  const { controls } = props;\n  const editor = useSlate();\n  const { selection } = editor;\n  if (selection) {\n    const eligableControls = controls.filter(control => {\n      const [match] = SlateEditor.nodes(editor, {\n        match: n => {\n          if (control.typeMatch && typeof n.type === \"string\") {\n            if (matchesType(n as ChiefElement, control.typeMatch)) {\n              return true;\n            }\n          }\n          else if (!control.typeMatch &&\n            !SlateEditor.isVoid(editor, n) &&\n            typeof n.type === \"string\") {\n            return true;\n          }\n          return false;\n        }\n      });\n      return Boolean(match);\n    });\n    if (eligableControls.length > 0) {\n      const groupedControls = groupBy(eligableControls, \"category\");\n      return (\n        <StyledToolBox>\n          <ToolsWrapper>\n            {Object.entries(groupedControls).map(([, groupedControls]) => (\n              <React.Fragment>\n                {groupedControls.map(control => {\n                  if (control.Component) {\n                    return <control.Component />;\n                  }\n                  const renderControl = control.render;\n                  return typeof renderControl === \"function\"\n                    ? renderControl(editor)\n                    : renderControl;\n                })}\n                <ToolDivider />\n              </React.Fragment>\n            ))}\n          </ToolsWrapper>\n        </StyledToolBox>\n      );\n    }\n  }\n  return null;\n}\n","import React from \"react\";\nimport { AddonProps } from \"../../addon\";\nimport { useRenderLeaf } from \"../../chief\";\n\nexport function TextColorAddon(props: AddonProps) {\n  useRenderLeaf({\n    renderLeaf: props => {\n      if (typeof props.leaf[\"color\"] === \"string\")\n        return (\n          <span\n            style={{ color: props.leaf[\"color\"] as string }}\n            {...props.attributes}\n          >\n            {props.children}\n          </span>\n        );\n      return undefined;\n    }\n  });\n  return null;\n}\n","import React, { useState } from \"react\";\nimport {\n  Editor,\n  Chief,\n  // Addons\n  HeadingsAddon,\n  BoldAddon,\n  ItalicAddon,\n  UnderlineAddon,\n  StrikethroughAddon,\n  ImageAddon,\n  ResetToParagraphAddon,\n  PreventNewlineAddon,\n  LinkAddon,\n  ListsAddon,\n  BlockTabAddon,\n  ParagraphAddon,\n  TextColorAddon,\n  LabelsAddon,\n  // Block toolbar addon\n  BlockInsert,\n  headingBlockControls,\n  BlockInsertControls,\n  // Custom addon creation\n  AddonProps,\n  useRenderElement,\n  InputWrapper,\n  usePlugin,\n  HoverToolProvider,\n  imageBlockControls,\n  HoverToolControls,\n  italicControl,\n  strikethroughControl,\n  underlineControl,\n  headingContextControls,\n  linkControl,\n  // Presentation\n  ChiefPresentation\n} from \"react-chief-editor\";\nimport { Node, Element } from \"slate\";\nimport styled, { css } from \"styled-components\";\n\nconst editorLabels = {\n  \"marks.bold\": \"Fed\",\n  \"marks.italic\": \"Kursiv\",\n  \"marks.strikethrough\": \"Gennemstreg\",\n  \"marks.underline\": \"Understreg\",\n  \"elements.link\": \"Link\",\n  \"elements.link.placeholder\": \"Indsæt eller skriv link\",\n  \"elements.link.btn.link\": \"Tilføj\",\n  \"elements.link.btn.unlink\": \"Fjern\",\n  \"elements.paragraph.hint\": \"Klik for at redigere\",\n  \"elements.paragraph.placeholder\": \"Tekst\",\n  \"elements.heading.h1.placeholder\": \"Overskrift 1\",\n  \"elements.heading.h2.placeholder\": \"Overskrift 2\",\n  \"elements.heading.h3.placeholder\": \"Overskrift 3\",\n  \"elements.heading.h4.placeholder\": \"Overskrift 4\",\n  \"elements.heading.h5.placeholder\": \"Overskrift 5\",\n  \"elements.heading.h6.placeholder\": \"Overskrift 6\"\n};\n\nfunction ExampleCustomAddon(props: AddonProps) {\n  usePlugin({\n    isVoid: isVoid => element =>\n      Element.isElement(element) && element.type === \"custom_void_element\"\n        ? true\n        : isVoid(element)\n  });\n\n  useRenderElement({\n    typeMatch: /custom_void_element/,\n    renderElement: (props, editor) => {\n      return (\n        <div {...props.attributes}>\n          <InputWrapper>\n            <input type=\"text\" />\n          </InputWrapper>\n          {props.children}\n        </div>\n      );\n    }\n  });\n\n  return null;\n}\n\nconst ContentStyle = styled.div`\n  font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n  color: rgba(28, 98, 116);\n  font-size: 18px;\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    color: rgba(153, 109, 33);\n  }\n  a {\n    color: rgba(153, 109, 33);\n  }\n`;\n\nfunction App() {\n  const [value, setValue] = useState<Node[]>([\n    {\n      type: \"h1\",\n      children: [{ text: \"Dark\" }]\n    },\n    {\n      type: \"paragraph\",\n      children: [\n        {\n          text:\n            \"Dark er en tysksproget web-tv-serie skabt af Baran bo Odar og Jantje Friese for Netflix. Serien havde premiere på Netflix 1. december 2017. Den første sæson – på ti afsnit – blev hovedsagelig godt modtaget, med positive og negative sammenligninger med Stranger Things, en anden overnaturlig thrillerserie fra Netflix\"\n        },\n        {\n          text: \"red\",\n          color: \"red\"\n        }\n      ]\n    },\n    {\n      type: \"h1\",\n      children: [{ text: \"Images\" }]\n    },\n    {\n      type: \"image\",\n      width: 700,\n      height: 420,\n      align: \"left\",\n      url:\n        \"https://occ-0-1068-1723.1.nflxso.net/dnm/api/v6/9pS1daC2n6UGc3dUogvWIPMR_OU/AAAABSJBCX9UxJkkZH_NLhm0nynLxHTqy99ETHJuidWOohECj4qKD3kqC8kr4gk2anceRXPMLULS3hruYHK56hpZCSsWD1GqNO4GaWrot7bwzPHJqxfT.jpg?r=2af\",\n      children: [\n        {\n          text: \"asd\"\n        }\n      ]\n    },\n    {\n      type: \"h1\",\n      children: [{ text: \"Lists\" }]\n    },\n    {\n      type: \"h2\",\n      children: [{ text: \"Ordered\" }]\n    },\n    {\n      type: \"ordered-list\",\n      children: [\n        { type: \"list-item\", children: [{ text: \"Item 1\" }] },\n        { type: \"list-item\", children: [{ text: \"item 2\" }] }\n      ]\n    },\n    {\n      type: \"h2\",\n      children: [{ text: \"Unordered\" }]\n    },\n    {\n      type: \"unordered-list\",\n      children: [\n        { type: \"list-item\", children: [{ text: \"Item \" }] },\n        { type: \"list-item\", children: [{ text: \"item\" }] }\n      ]\n    }\n  ]);\n\n  const addons = (\n    <>\n      <LabelsAddon labels={editorLabels}></LabelsAddon>\n      <ParagraphAddon></ParagraphAddon>\n      <BoldAddon></BoldAddon>\n      <ItalicAddon></ItalicAddon>\n      <UnderlineAddon></UnderlineAddon>\n      <StrikethroughAddon></StrikethroughAddon>\n      <HeadingsAddon></HeadingsAddon>\n      <ImageAddon></ImageAddon>\n      <ResetToParagraphAddon></ResetToParagraphAddon>\n      <PreventNewlineAddon></PreventNewlineAddon>\n      <PreventNewlineAddon></PreventNewlineAddon>\n      <LinkAddon></LinkAddon>\n      <ListsAddon></ListsAddon>\n      <BlockTabAddon></BlockTabAddon>\n      <TextColorAddon></TextColorAddon>\n      {/* <ExampleVideoAddon labels={{ name: \"ExampleVideo\" }}></ExampleVideoAddon> */}\n    </>\n  );\n\n  console.log(value);\n\n  return (\n    <div style={{ padding: \"1em\" }}>\n      <ContentStyle>\n        <Chief\n          value={value}\n          onChange={value => setValue(value)}\n          theme={{\n            overrides: {\n              ui: css`\n                /* font-family: monospace; */\n              `\n            }\n          }}\n        >\n          {addons}\n          <div\n            style={{\n              marginLeft: 20\n            }}\n          >\n            <BlockInsert>\n              <BlockInsertControls\n                controls={[\n                  ...headingBlockControls,\n                  ...imageBlockControls,\n                  ListsAddon.Control\n                ]}\n              />\n            </BlockInsert>\n            <HoverToolProvider\n              hoverTool={\n                <HoverToolControls\n                  controls={[\n                    BoldAddon.Control,\n                    italicControl,\n                    strikethroughControl,\n                    underlineControl,\n                    ...headingContextControls,\n                    linkControl\n                  ]}\n                />\n              }\n            >\n              <Editor\n                spellCheck={false}\n                style={{ margin: 10, overflow: \"auto\", minHeight: 500 }}\n              ></Editor>\n            </HoverToolProvider>\n          </div>\n        </Chief>\n      </ContentStyle>\n      <ContentStyle>\n        <ChiefPresentation\n          value={value}\n          presenters={[\n            ParagraphAddon.Presenter,\n            BoldAddon.Presenter,\n            ItalicAddon.Presenter,\n            StrikethroughAddon.Presenter,\n            UnderlineAddon.Presenter,\n            HeadingsAddon.Presenter,\n            LinkAddon.Presenter,\n            ListsAddon.Presenter,\n            ImageAddon.Presenter\n          ]}\n        ></ChiefPresentation>\n      </ContentStyle>\n    </div>\n  );\n}\n\nexport default App;\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}